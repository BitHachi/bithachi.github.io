<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>this与super大详解</title>
      <link href="/posts/720ba9d4.html"/>
      <url>/posts/720ba9d4.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-this"><a href="#1-this" class="headerlink" title="1.this"></a>1.this</h2><h3 id="1-1-this是什么？"><a href="#1-1-this是什么？" class="headerlink" title="1.1. this是什么？"></a>1.1. this是什么？</h3><ul><li>this是Java中的关键字，它的作用和其词义很接近,<code>这个</code>。<br>它在方法内部使用，即这个方法所属对象的引用；<br>它在构造器内部使用，表示该构造器正在初始化的对象。</li><li>this 可以调用类的属 性、方法和构造器</li><li>什么时候使用this关键字呢？<br>当在方法内需要用到调用该方法的对象时，就用this。<br>具体的：我们可以用this来区分属性和局部变量。<br>比如：this.name = name;</li></ul><h3 id="1-2-this调用对象中的属性、构造器和方法"><a href="#1-2-this调用对象中的属性、构造器和方法" class="headerlink" title="1.2 this调用对象中的属性、构造器和方法"></a>1.2 this调用对象中的属性、构造器和方法</h3><p><strong>规则：</strong></p><ol><li>在任意方法或构造器内，如果使用当前类的成员变量或成员方法可以在其前面添加this，增强程序的阅读性。不过，通常我们都习惯省略this。</li><li>当形参与成员变量同名时，如果在方法内或构造器内需要使用成员变量，必须添加this来表明该变量是类的成员变量</li><li>使用this访问属性和方法时，如果在本类中未找到，会从父类中查找</li><li>this可以在一个类中相互调用构造器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123; <span class="comment">// 无参构造器</span></span><br><span class="line">        System.out.println(<span class="string">"新对象实例化"</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(); <span class="comment">// 调用本类中的无参构造器</span></span><br><span class="line">        <span class="keyword">this</span>.name = name ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(name) ; <span class="comment">// 调用有一个参数的构造器</span></span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"对象的姓名："</span> + name);</span><br><span class="line">        <span class="keyword">this</span>.speak();<span class="comment">//this指代当前操作的对象p1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> age=<span class="number">20</span>;</span><br><span class="line">        System.out.println(<span class="string">"局部变量年龄： "</span>+age);</span><br><span class="line">        System.out.println(<span class="string">"对象的年龄："</span> + <span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">"王五"</span>, <span class="number">18</span>);</span><br><span class="line">        p1.getInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">新对象实例化</span><br><span class="line">对象的姓名：王五</span><br><span class="line">局部变量年龄： <span class="number">20</span></span><br><span class="line">对象的年龄：<span class="number">18</span></span><br></pre></td></tr></table></figure><h2 id="2-super"><a href="#2-super" class="headerlink" title="2.super"></a>2.super</h2><h3 id="2-1-super是什么？"><a href="#2-1-super是什么？" class="headerlink" title="2.1 super是什么？"></a>2.1 super是什么？</h3><ul><li><p>super是Java的关键字</p></li><li><p>在Java类中使用super来调用父类中的指定操作：</p><ol><li><p>super可用于访问父类中定义的<code>属性</code>，protected,public,default</p></li><li><p>super可用于调用父类中定义的<code>成员方法</code></p></li><li><p>super可用于在子类构造器中调用<code>父类的构造器</code></p><ul><li><p>当父类中没有空参数的构造器时，子类的构造器必须通过<code>this(参数列表</code>或者<code>super( 参数列表)</code>语句指定调用本类或者父类中相应的构造器。同时，<code>只能”二选一”，且必须放在构造器的首行</code></p></li><li><p><code>子类</code>中所有的<code>构造器默认</code>都会<code>访问父类</code>中 <code>空参数</code>的<code>构造器</code></p></li><li><p>如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有无参的构造器，则<code>编译出错</code></p></li></ul></li></ol></li></ul><p><strong>注意：</strong></p><ol><li>当子父类出现同名成员时，可以用super表明调用的是父类中的成员</li><li>super的追溯不仅限于<code>直接父类</code></li><li>super和this的用法相像，this代表本类对象的引用，super代表父类的内存空间的标识</li></ol><h3 id="2-2-super调用父类的属性、构造器、方法"><a href="#2-2-super调用父类的属性、构造器、方法" class="headerlink" title="2.2 super调用父类的属性、构造器、方法"></a>2.2 super调用父类的属性、构造器、方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Program</span>: JavaSE</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: Person</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Mr.BitHachi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span>: 2020-07-30 18:07</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: V1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Date birthDate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String isPublic=<span class="string">"isPublic"</span>;</span><br><span class="line">    <span class="keyword">protected</span> String isProtected=<span class="string">"isProtected"</span>;</span><br><span class="line">    <span class="keyword">private</span> String isPrivate=<span class="string">"isProtected"</span>;</span><br><span class="line">    String isDefault=<span class="string">"isDefault"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfopublic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"getInfopublic：Name: "</span> + name + <span class="string">"  age: "</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getInfoPrivate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"getInfoPrivate：Name: "</span> + name + <span class="string">"  age: "</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getInfoProtected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"getInfoProtected：Name: "</span> + name + <span class="string">"  age: "</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function">String <span class="title">getInfoDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"getInfoDefault：Name: "</span> + name + <span class="string">"  age: "</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, Date d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.birthDate = d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(name, age, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, Date d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(name, <span class="number">22</span>, d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(name, <span class="number">22</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Program</span>: JavaSE</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: Studnet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Mr.BitHachi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span>: 2020-07-30 20:25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: V1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String school;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age);</span><br><span class="line">        school = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);<span class="comment">//调用父类的构造器</span></span><br><span class="line">        school = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//this和super测试调用父类的属性和方法,不能调用父类的private修饰的属性和方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="keyword">this</span>.isDefault);</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.isProtected);</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.isPublic);</span><br><span class="line">        System.out.println(<span class="string">"----------------"</span>);</span><br><span class="line">        System.out.println(<span class="keyword">super</span>.isDefault);</span><br><span class="line">        System.out.println(<span class="keyword">super</span>.isProtected);</span><br><span class="line">        System.out.println(<span class="keyword">super</span>.isPublic);</span><br><span class="line">        System.out.println(<span class="string">"----------------"</span>);</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getInfoDefault());</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getInfoProtected());</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getInfopublic());</span><br><span class="line">        System.out.println(<span class="string">"----------------"</span>);</span><br><span class="line">        System.out.println(<span class="keyword">super</span>.getInfoDefault());</span><br><span class="line">        System.out.println(<span class="keyword">super</span>.getInfoProtected());</span><br><span class="line">        System.out.println(<span class="keyword">super</span>.getInfopublic());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译出错: 没有 super(),系统将调用父类无参数的构造器。</span></span><br><span class="line">    <span class="comment">// Person没有无参数的构造器</span></span><br><span class="line"><span class="comment">//    public Student(String s) &#123;</span></span><br><span class="line"><span class="comment">//        school = s;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student s=<span class="keyword">new</span> Student(<span class="string">"BitHachi"</span>,<span class="string">"加里敦大学"</span>);</span><br><span class="line">        s.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">isDefault</span><br><span class="line">isProtected</span><br><span class="line">isPublic</span><br><span class="line">----------------</span><br><span class="line">isDefault</span><br><span class="line">isProtected</span><br><span class="line">isPublic</span><br><span class="line">----------------</span><br><span class="line">getInfoDefault：Name: BitHachi  age: <span class="number">22</span></span><br><span class="line">getInfoProtected：Name: BitHachi  age: <span class="number">22</span></span><br><span class="line">getInfopublic：Name: BitHachi  age: <span class="number">22</span></span><br><span class="line">----------------</span><br><span class="line">getInfoDefault：Name: BitHachi  age: <span class="number">22</span></span><br><span class="line">getInfoProtected：Name: BitHachi  age: <span class="number">22</span></span><br><span class="line">getInfopublic：Name: BitHachi  age: <span class="number">22</span></span><br></pre></td></tr></table></figure><h2 id="3-this与super-比较"><a href="#3-this与super-比较" class="headerlink" title="3. this与super 比较"></a>3. this与super 比较</h2><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200730205424.png" alt="image-20200730205424453"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JavaSE </tag>
            
            <tag> this </tag>
            
            <tag> super </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象OOP三大特性：继承、封装、多态</title>
      <link href="/posts/c72fe2cc.html"/>
      <url>/posts/c72fe2cc.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-继承"><a href="#1-继承" class="headerlink" title="1.继承"></a>1.继承</h2><p>继承是<strong>类与类的一种关系</strong>，子类拥有父类的所有(public,default,protected)属性和方法，从而实现了代码的复用。**</p><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200730195024.png" alt="image-20200730195023660"></p><p><strong>继承与实现的区别：</strong></p><ol><li>概念不同</li></ol><p>​    继承：子类与父类的继承。如果多个类的某个部分的功能相同，那么可以抽象出一个类出来，把他们的相同部分都放到父类里，让他们都继承这个类。</p><p>​    实现：接口的实现。如果多个类都有一个行为，但是处理的方法方式不同，那么就定义一个接口，也就是一个标准，让各个类分别实现这个接口，各自实现自己具体的处理方法。</p><ol start="2"><li>关键词不同</li></ol><p>​    继承：extends，实现：implements</p><ol start="3"><li>数量不同</li></ol><p>​    单继承，多实现。</p><ol start="4"><li>属性不同</li></ol><p>​    在接口中只能定义全局常量（<strong>public static final</strong> ）,和空的方法体；而在继承中可以定义属性,方法等…</p><blockquote><p><strong>注*</strong>：JDK 1.8 以后，接口里可以有静态方法和方法体了。*</p></blockquote><ol start="5"><li>限制不同</li></ol><p>​    某个接口被类实现时,在类中一定要实现接口中的抽象方法；而继承则无需。</p><h2 id="2-封装"><a href="#2-封装" class="headerlink" title="2.封装"></a>2.封装</h2><ol><li><p>为什么需要封装？<br> 我要用洗衣机，只需要按一下开关和洗涤模式就可以了。有必要了解洗衣机内部的结构吗？有必要碰电动机吗？<br> 如果我们把洗衣机的内部结构暴露出来，当我们使用的时候可能会误操作，碰到一些核心部件更改了配置，导致洗衣机功能出现问题，不能正常工作，所以封装就显得很有必要，把需要暴露的暴露出来，比如洗衣机的一些按钮和加水的地方，不需要的隐藏起来，比如发动机，内部芯片电线等，这样就保证了洗衣机的稳定工作和安全性。</p></li><li><p>封装性的设计思想：<code>隐藏</code>对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。<code>把该隐藏的隐藏起来，该暴露的暴露出来</code>。</p></li><li><p>封装的程序设计意义：为了实现程序设计的“高内聚，低耦合”。</p><ul><li>高内聚 ：类的内部数据操作细节自己完成，不允许外部干涉；</li><li>低耦合 ：仅对外暴露少量的方法用于使用。</li></ul><blockquote><p>例如：通过将数据声明为私有的(private)，再提供公共的（public）方法:getXxx() 和setXxx()实现对该属性的操作,以实现高内聚与低耦合。</p></blockquote></li></ol><h2 id="3-多态"><a href="#3-多态" class="headerlink" title="3.多态"></a>3.多态</h2><p>Java中的多态主要指<code>引用多态</code>和<code>方法多态</code>。</p><p> <code>引用多态</code>：父类引用可以指向本类对象，也可指向子类对象。引用多态的强大主要体现在调用属性、方法时，可以根据引用具体指向的对象去调用，例如：子类中<code>重写</code>了父类方法。</p><p>  <code>方法多态</code>：子类中可以重写父类的方法，在调用方法时根据引用指向的子类对象决定调用哪个具体的方法。方法多态的强大主要体现在可以根据调用时参数的不同，而自主匹配调用的方法，例如：<code>重载</code>。</p><p>  方法<code>重写与重载</code>的区别：</p><p>  <code>重写</code>：一般发生在有继承关系的子类中，子类中定义了一个方法，其<strong>方法名、返回值类型、参数列表</strong> 与父类中某个方法一样，此时就是子类中重写(覆盖)了父类的同名方法。</p><ul><li><p>子类重写的方法访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。</p></li><li><p>子类方法抛出的异常不能大于父类被重写方法的异常</p></li><li><p>子类不能重写父类中声明为private权限的方法</p><p><code>重载</code>(Overloading)：发生在同一个类中，存在 多个方法的<strong>方法名相同，参数列表不同</strong>。参数列表不同指的是参数个数、参数类型或者参数的顺序不同。</p></li><li><p>被重载的方法可以声明新的或更广的检查异常；</p></li><li><p>被重载的方法可以改变访问修饰符；</p></li><li><p>被重载的方法返回类型可以不同；</p></li></ul><blockquote><p>子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为<br>static的（不是重写）。因为static方法是属于类的，子类无法覆盖父类的方法。</p></blockquote><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200730200939.png" alt="image-20200730200939545"></p><p>父类引用调用方法时，根据引用指向的对象决定调用父类定义的方法还是子类定义的方法，这体现了多态。      </p><p>调用方法时通过传递给它们的不同个数和类型的参数来决定具体使用哪个方法，这也体现了多态。</p><p><strong>注意：</strong></p><p>这类我们讨论多态调用属性和方法的规则：</p><p>这里假设两个类Student extends Person ，父类是Person，子类是Student</p><blockquote><p>Person 引用指向子类对象Student，<code>Person p=new Student()</code></p><p>当p调用属性时：p只能调用Person类的属性，即使Student定义了一模一样的属性，p实际调用的也是Person类的属性</p><p>当p调用方法时：</p><pre><code>1. Student 没有重写Person的方法，那么p只能调用Person类里面的方法 2. Student 重写了 Person的方法，那么p就在编译时是Person的方法，运行时是Student重写的方法。</code></pre></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 继承 </tag>
            
            <tag> 封装 </tag>
            
            <tag> 多态 </tag>
            
            <tag> 重写 </tag>
            
            <tag> 重载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows10+PicGo+七牛云+Typora搭建写作环境与图床</title>
      <link href="/posts/641e0332.html"/>
      <url>/posts/641e0332.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-需要的环境工具"><a href="#1-需要的环境工具" class="headerlink" title="1.需要的环境工具"></a>1.需要的环境工具</h2><ul><li>Typora : markdown 文档写作工具，使用PicGo<code>间接</code>将图片上传到七牛云</li><li>PicGo : 图床工具，负责<code>直接</code>上传图片到七牛云</li><li>七牛云：存储从PicGo上传来的图片，为什么选择七牛云，因为每个月有10G的免费流量和存储空间，可以白嫖（哈哈）</li><li>域名：需要一个域名绑定七牛云的CDN，以访问图片，域名可以从阿里云，腾讯云等平台购买，域名需要备案。</li></ul><h2 id="2-下载软件"><a href="#2-下载软件" class="headerlink" title="2.下载软件"></a>2.下载软件</h2><h3 id="2-1-Typora"><a href="#2-1-Typora" class="headerlink" title="2.1 Typora"></a>2.1 Typora</h3><ul><li>下载地址：<a href="https://typora.io/" target="_blank" rel="noopener">https://typora.io/</a>，下载后直接安装next默认就行了，可以根据自己喜好更改安装路径</li></ul><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200729204003.png" alt="image-20200729204003283"></p><h3 id="2-2-PicGo"><a href="#2-2-PicGo" class="headerlink" title="2.2 PicGo"></a>2.2 PicGo</h3><ul><li>下载地址：<a href="https://github.com/Molunerfinn/picgo/releases" target="_blank" rel="noopener">https://github.com/Molunerfinn/picgo/releases</a>,下载后直接安装next默认就行了，可以根据自己喜好更改安装路径</li></ul><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200729204412.png" alt="image-20200729204412318"></p><h3 id="2-3软件图标"><a href="#2-3软件图标" class="headerlink" title="2.3软件图标"></a>2.3软件图标</h3><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200729204635.png" alt="image-20200729204635137"></p><h2 id="3-正式开始配置"><a href="#3-正式开始配置" class="headerlink" title="3.正式开始配置"></a>3.正式开始配置</h2><h3 id="3-1-注册七牛云"><a href="#3-1-注册七牛云" class="headerlink" title="3.1 注册七牛云"></a>3.1 注册七牛云</h3><ul><li>点击<a href="https://www.qiniu.com/" target="_blank" rel="noopener">七牛云官网</a> → 点击右上角免费注册 → 按步骤填写相关信息-&gt;进行相关的实名认证</li></ul><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200729205616.png" alt="image-20200729205616919"></p><h3 id="3-2-配置对象存储"><a href="#3-2-配置对象存储" class="headerlink" title="3.2 配置对象存储"></a>3.2 配置对象存储</h3><blockquote><p>七牛云对象存储就是存储你图片的地方</p></blockquote><ul><li>打开七牛云控制台-&gt;点击对象存储</li></ul><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200729205747.png" alt="image-20200729205747005"></p><ul><li>点击新建空间</li></ul><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200729205811.png" alt="image-20200729205811290"></p><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200729205924.png" alt="image-20200729205924364"></p><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200729210009.png" alt="image-20200729210009650"></p><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200729210128.png" alt="image-20200729210128499"></p><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200729210401.png" alt="image-20200729210401673"></p><h3 id="3-3-DNS配置"><a href="#3-3-DNS配置" class="headerlink" title="3.3 DNS配置"></a>3.3 DNS配置</h3><ul><li>绑定cname</li></ul><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200729211649.png" alt="image-20200729211649079"></p><ul><li>前往你域名购买的服务商平台进行CNAME配置</li></ul><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200729211451.png" alt="image-20200729211451426"></p><p>以上配置成功之后，就可以上传图片，并通过你的域名来访问图片了</p><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200729211812.png" alt="image-20200729211812258"></p><h3 id="3-4-配置PicGo"><a href="#3-4-配置PicGo" class="headerlink" title="3.4 配置PicGo"></a>3.4 配置PicGo</h3><ul><li><p>上面我们已经可以通过七牛云配置来访问图片了，但是上传图片和使用链接到Typora还是比较麻烦的，于是我们使用PicGo软件来简化这一步骤。</p></li><li><p>接下来进行配置</p><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200729212326.png" alt="image-20200729212326328"></p></li><li><p>上面的AK和SK就是下面图片所显示的的缩写</p></li></ul><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200729212232.png" alt="image-20200729212232427"></p><ul><li>关于存储区域，根据你当初申请对象存储空间时的地区来写代号</li></ul><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200729212533.png" alt="image-20200729212533624"></p><h3 id="3-5-配置Typora"><a href="#3-5-配置Typora" class="headerlink" title="3.5 配置Typora"></a>3.5 配置Typora</h3><ul><li>以上配置完毕，接下来我们配置Typora，可以实现截屏图片，粘贴复制直接生成mrakdown格式，简化PicGo上传步骤</li></ul><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200729213020.png" alt="image-20200729213020743"></p><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200729213111.png" alt="image-20200729213111212"></p><p>然后就可以在PicGo里面看到你上传的Typora测试图片了</p><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200729213318.png" alt="image-20200729213317978"></p><h2 id="4-PicGo上传图片的几种方式和格式"><a href="#4-PicGo上传图片的几种方式和格式" class="headerlink" title="4. PicGo上传图片的几种方式和格式"></a>4. PicGo上传图片的几种方式和格式</h2><ol><li>直接在Typoar里面粘贴或拖拽你需要的图片，会自动生成mrakdown方式链接到文档中，我个人最喜欢这种方式，简介快速</li></ol><ol start="2"><li>其它方式，直接见图叭</li></ol><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200729213525.png" alt="image-20200729213525180"></p><h2 id="5-相关问题"><a href="#5-相关问题" class="headerlink" title="5. 相关问题"></a>5. 相关问题</h2><ol><li>最近遇到一个问题，PicGo不能上传图片到七牛云，我这里的解决方案是查看日志然后修改PicGo的配置解决的，希望诸君遇到的时候，能给大家一个参考叭</li><li>我这里遇到的问题就是我明明配置的七牛云图床，日志文件里面居然是smms图床，不知道是不是PicGo的问题，我后来改了一下，重新启动PicGo才搞定。</li></ol><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200729213726.png" alt="image-20200729213726459"></p><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200729213945.png" alt="image-20200729213944978"></p><ul><li>修改配置文件</li></ul><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200729214003.png" alt="image-20200729214003794"></p><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200729214059.png" alt="image-20200729214059442"></p><blockquote><p>OK，完工，尽情享受Typora+PicGo+七牛云的写作环境叭。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PicGo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解：面向对象与面向过程的比较 &amp; 类之间的关系：泛化、实现、依赖、关联、聚合、组合</title>
      <link href="/posts/769cd987.html"/>
      <url>/posts/769cd987.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-面向对象程序设计概述"><a href="#1-面向对象程序设计概述" class="headerlink" title="1.面向对象程序设计概述"></a>1.面向对象程序设计概述</h2><ul><li>面向对象程序设计（简称 OOP) 是当今主流的程序设计范型， 它已经取代了 20 世纪 70 年代的“ 结构化” 过程化程序设计开发技术。</li></ul><h3 id="1-1-面向对象程序设计"><a href="#1-1-面向对象程序设计" class="headerlink" title="1.1 面向对象程序设计"></a>1.1 面向对象程序设计</h3><ul><li><code>Java 是完全面向对象的， 必须熟悉 OOP 才能 够编写 Java 程序</code>。 </li><li>面向对象的程序是由对象组成的， 每个对象包含对用户公开的特定功能部分和隐藏的实 现部分。程序中的很多对象来自标准库，还有一些是自定义的。</li></ul><h3 id="1-2-传统结构化程序设计"><a href="#1-2-传统结构化程序设计" class="headerlink" title="1.2 传统结构化程序设计"></a>1.2 传统结构化程序设计</h3><ul><li><code>传统的结构化程序设计</code>通过设计一系列的过程（即算法）来求解问题。一旦确定了这些 过程， 就要开始考虑存储数据的方式。这就是 Pascal 语言的设计者 Niklaus Wirth将其著作命 名为《算法 + 数据结构 = 程序》 </li><li>在 Wirth命名的书名中， <code>算法是第一位的，数据结构是第二位的</code>，这就明确地表述了程序员的工作方式。 先要确定如何操作数据， 然后再决定如何组织数据， 以便于数据操作。 而 <code>OOP 却调换了这个次序， 将数据放在第一位，然后再考虑操作数据的算法</code>。 </li></ul><h3 id="1-3-面向对象与面向过程举例"><a href="#1-3-面向对象与面向过程举例" class="headerlink" title="1.3 面向对象与面向过程举例"></a>1.3 面向对象与面向过程举例</h3><p><strong>举个例子简单说明面向过程开发与面向对象oop开发的不同：</strong></p><blockquote><ul><li>对于一些规模较小的问题， 将其分解为过程的开发方式比较理想。</li><li>而面向对象更加适用 于解决规模较大的问题。</li><li>要想实现一个简单的 Web 浏览器可能需要大约 2000 个过程，这些<code>过程</code>可能需要对一组<code>全局数据</code>进行操作。</li><li>采用<code>面向对象</code>的设计风格， 可能只需要<code>大约 100 个 类</code>，每个类平均包含 20 个方法（如图 4-丨所示)。</li><li>后者更易于程序员掌握， 也容易找到 bug 假设给定对象的数据出错了，在访问过这个数据项的 20 个方法中查找错误要比在 2000 个过 程中查找容易得多<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200418220221214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul></blockquote><h2 id="2-类之间的关系"><a href="#2-类之间的关系" class="headerlink" title="2.类之间的关系"></a>2.类之间的关系</h2><p><strong>在类之间， 最常见的关系有：</strong></p><ol><li>泛化/继承（Generalization）</li><li>实现（Realization）</li><li>关联（Association)</li><li>聚合（Aggregation）</li><li>组合(Composition)</li><li>依赖(Dependency)</li></ol><blockquote><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200419122034743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></blockquote><h3 id="2-1-泛化-继承"><a href="#2-1-泛化-继承" class="headerlink" title="2.1   泛化/继承"></a>2.1   泛化/继承</h3><ul><li>含义：继承指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力。</li><li>代码体现：在Java中继承关系通过关键字<code>extends</code>明确标识</li><li>箭头指向：继承用一条带空心三角箭头的实线表示，从子类指向父类，或者子接口指向父接口。 </li></ul><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200730233912.png" alt="image-20200730233912528"></p><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200730235837.png" alt="image-20200730235837723"></p><h3 id="2-2-实现"><a href="#2-2-实现" class="headerlink" title="2.2  实现"></a>2.2  实现</h3><ul><li>含义：实现指的是一个class类实现interface接口（可以是多个）的功能，实现是类与接口之间最常见的关系。</li><li>代码体现：在Java中此类关系通过关键字<code>implements</code>明确标识</li><li>箭头指向：实现用一条带空心三角箭头的虚线表示，从类指向实现的接口。 </li></ul><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200730234024.png" alt="image-20200730234024499"></p><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200730235911.png" alt="image-20200730235911565"></p><h3 id="2-3-依赖"><a href="#2-3-依赖" class="headerlink" title="2.3 依赖"></a>2.3 依赖</h3><ul><li><p>含义：一种使用的关系，即一个类的实现需要另一个类的协助，要尽量不使用双向的互相依赖.</p><p>这种使用关系是具有偶然性的、临时性的、非常弱的，类B的变化会影响到类A。</p></li><li><p>代码表现：<code>局部变量、方法的参数或者对静态方法的调用；</code>类B作为方法参数(局部变量)被类A在某个method方法中使用</p></li><li><p>箭头指向：用带箭头的虚线表示，指向被使用者</p></li></ul><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200730234318.png" alt="image-20200730234318100"></p><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200730235930.png" alt="image-20200730235930003"></p><h3 id="2-4-关联"><a href="#2-4-关联" class="headerlink" title="2.4 关联"></a>2.4 关联</h3><ul><li><p>含义：是一种拥有的关系，它使一个类知道另一个类的属性和方法；</p><p>这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的，而且双方的关系一般是平等的。</p><p>如：老师与学生，丈夫与妻子关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。</p></li><li><p>代码体现：<code>成员变量。</code>被关联类B以类的属性形式出现在关联类A中，也可能是关联类A引用了一个类型为被关联类B的全局变量。</p></li><li><p>箭头指向： 带普通箭头的实心线，指向被拥有者</p></li></ul><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200730235106.png" alt="image-20200730235106481"></p><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200730235804.png" alt="image-20200730235804652"></p><h3 id="2-5-聚合"><a href="#2-5-聚合" class="headerlink" title="2.5 聚合"></a>2.5 聚合</h3><ul><li><p>含义：聚合是关联关系的一种特例，它体现的是整体与部分的关系，即has-a的关系。</p><p>此时整体与部分之间是可分离的，它们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享。</p><p>比如计算机与CPU、公司与员工的关系等，比如一个航母编队包括海空母舰、驱护舰艇、舰载飞机及核动力攻击潜艇等。</p></li><li><p>代码体现：成员变量；和关联关系是一致的，只能从语义级别来区分</p></li><li><p>箭头指向：带空心菱形的实心线，菱形指向整体</p></li></ul><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200730235742.png" alt="image-20200730235741993"></p><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200730235750.png" alt="image-20200730235750830"></p><h3 id="2-5-组合"><a href="#2-5-组合" class="headerlink" title="2.5  组合"></a>2.5  组合</h3><ul><li><p>含义：组合也是关联关系的一种特例，它体现的是一种contains-a的关系，这种关系比聚合更强，也称为强聚合。<br>它同样体现整体与部分间的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束，</p><p>比如人和人的大脑。比如公司和部门是整体和部分的关系，没有公司就不存在部门。</p></li><li><p>代码体现：成员变量；和关联关系是一致的，只能从语义级别来区分</p></li><li><p>箭头指向：带实心菱形的实线，菱形指向整体</p></li></ul><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200731000327.png" alt="image-20200731000327025"></p><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200731000334.png" alt="image-20200731000334893"></p><h3 id="2-6-强弱顺序"><a href="#2-6-强弱顺序" class="headerlink" title="2.6 强弱顺序"></a>2.6 强弱顺序</h3><p>各种关系的强弱顺序：<strong>泛化/继承 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖</strong></p><h3 id="2-7-一张图融会贯通"><a href="#2-7-一张图融会贯通" class="headerlink" title="2.7 一张图融会贯通"></a>2.7 一张图融会贯通</h3><p>下面这张UML图，比较形象地展示了各种类图关系：</p><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200731001326.png" alt="image-20200731001326493"></p><h2 id="3-参考文献"><a href="#3-参考文献" class="headerlink" title="3. 参考文献"></a>3. 参考文献</h2><ul><li><a href="http://www.uml.org.cn/oobject/201609062.asp#" target="_blank" rel="noopener">http://www.uml.org.cn/oobject/201609062.asp#</a></li><li><a href="https://www.cnblogs.com/liuling/archive/2013/05/03/classrelation.html" target="_blank" rel="noopener">https://www.cnblogs.com/liuling/archive/2013/05/03/classrelation.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> OOP </tag>
            
            <tag> POP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复制数组的四种方法以及时间效率比较</title>
      <link href="/posts/de8ce5fb.html"/>
      <url>/posts/de8ce5fb.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="https://blog.csdn.net/qq_33591903/article/details/82532626" target="_blank" rel="noopener">https://blog.csdn.net/qq_33591903/article/details/82532626</a></p></blockquote><h2 id="零、数组复制效率的比较"><a href="#零、数组复制效率的比较" class="headerlink" title="零、数组复制效率的比较"></a>零、数组复制效率的比较</h2><p>java中数组复制的方式，有以下几种</p><p>（1）System.arraycopy（）；</p><p>（2）Arrays.copyOf（）；</p><p>（3）clone（）；</p><p>（4）for循环</p><p>今天我们比较一下这四者的效率</p><hr><h2 id="一、System-arraycopy（）"><a href="#一、System-arraycopy（）" class="headerlink" title="一、System.arraycopy（）"></a>一、System.arraycopy（）</h2><p>此方法的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,Object dest, <span class="keyword">int</span> destPos,<span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure><p>可见此方法是一个本地方法，方法对应的实现不在当前文件里，而是在其他语言实现的的文件的，比如C、C++中。</p><p>使用本地方法，案例来说效率应该最高，稍后进行效率测试。</p><hr><h2 id="二、Arrays-copyOf（）"><a href="#二、Arrays-copyOf（）" class="headerlink" title="二、Arrays.copyOf（）"></a>二、Arrays.copyOf（）</h2><p>此方法的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">      <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">   T[] copy = ((Object)newType == (Object)Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">? (T[]) new Object[newLength]</span><br><span class="line">: (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">      </span><br><span class="line">      System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">   Math.min(original.length, newLength));</span><br><span class="line"><span class="keyword">return</span> copy;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以看得出来，本质上调用的是System.arraycopy（）方法，也就是前一种方法，那么效率肯定比不上前一种数组复制方法。</p><hr><h2 id="三、clone（）"><a href="#三、clone（）" class="headerlink" title="三、clone（）"></a>三、clone（）</h2><p>此方法的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure><p>这个方法是Object类中的一个本地方法，这里虽然返回Object，看着需要强制类型转换，但Object子类重写了这个方法，会返回相应的类型。</p><hr><h2 id="四、for循环"><a href="#四、for循环" class="headerlink" title="四、for循环"></a>四、for循环</h2><p>最简单粗暴的一种方式，循环原始数组并直接赋值到目标数组中。</p><hr><h2 id="五、四种的比较"><a href="#五、四种的比较" class="headerlink" title="五、四种的比较"></a>五、四种的比较</h2><p>他们之间的效率比较需要从原始数组的大小出发。</p><p>先贴出比较的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day0908;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestArrayCopy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSystemArrayCopy</span><span class="params">(String[] orginal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start_time = System.nanoTime();</span><br><span class="line">        String[] target = <span class="keyword">new</span> String[orginal.length];</span><br><span class="line">        System.arraycopy(orginal, <span class="number">0</span>, target, <span class="number">0</span>, target.length);</span><br><span class="line">        <span class="keyword">long</span> end_time = System.nanoTime();</span><br><span class="line">        System.out.println(<span class="string">"使用System.arraycopy方法耗时:"</span> + (end_time - start_time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testArraysCopyOf</span><span class="params">(String[] orginal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start_time = System.nanoTime();</span><br><span class="line">        String[] target = <span class="keyword">new</span> String[orginal.length];</span><br><span class="line">        target = Arrays.copyOf(orginal, orginal.length);</span><br><span class="line">        <span class="keyword">long</span> end_time = System.nanoTime();</span><br><span class="line">        System.out.println(<span class="string">"使用Arrays.copyOf方法耗时:"</span> + (end_time - start_time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testClone</span><span class="params">(String[] orginal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start_time = System.nanoTime();</span><br><span class="line">        String[] target = <span class="keyword">new</span> String[orginal.length];</span><br><span class="line">        target = orginal.clone();</span><br><span class="line">        <span class="keyword">long</span> end_time = System.nanoTime();</span><br><span class="line">        System.out.println(<span class="string">"使用clone方法耗时:"</span> + (end_time - start_time));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testFor</span><span class="params">(String[] orginal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start_time = System.nanoTime();</span><br><span class="line">        String[] target = <span class="keyword">new</span> String[orginal.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; orginal.length; i++) &#123;</span><br><span class="line">            target[i] = orginal[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end_time = System.nanoTime();</span><br><span class="line">        System.out.println(<span class="string">"使用for循环耗时:"</span> + (end_time - start_time));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="comment">//需要改变原始数组的大小</span></span><br><span class="line">        String[] original = <span class="keyword">new</span> String[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; original.length; i++) &#123;</span><br><span class="line">            original[i] = <span class="string">"abcd"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"原始数组的大小:"</span> + original.length);</span><br><span class="line">        testSystemArrayCopy(original);</span><br><span class="line">        testArraysCopyOf(original);</span><br><span class="line">        testClone(original);</span><br><span class="line">        testFor(original);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较他们之间的效率需要从目标数组的大小出发。</p><p>【1】目标数组是个小数组，长度在200以内</p><p>四种方式的效率：</p><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200729191821.png" alt="image-20200729191820741"></p><p>可以看得出：Arrays.copyOf（）的效率最差，其余三种效率差异不大。</p><hr><p>【2】目标是个中等数组，长度以千为单位。</p><p>四种方式的效率：</p><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200729191857.png" alt="image-20200729191857013"></p><p>可以看得出，System.arraycopy（）与clone（）方式差异不大，使用for循环的方式，耗时比之前的情况变得严重起来。</p><hr><p>【3】目标数组是个大型数组，长度以万为单位。</p><p>四种方式的效率：</p><p> <img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200729192436.png" alt="image-20200729192436700"></p><p>可以看得出，此时System.arraycopy（）方法的效率最高，且数组长度在此基础增加时，此方法效率还是最高，而for循环的效率在这种情况下表现得十分糟糕。</p><hr><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>（1）原始数组长度不管是多少的时候，Arrays.copyOf（）的效率都比System.arraycopy（）差。</p><p>（2）原始数组长度比较小的时候，几百以内，for循环表现十分优异，并随着数组长度的增加，效率越来越低，因此，for循环适合于小型数组。</p><p>（3）原始数组长度中等的时候，比如几千的时候，两个本地方法的效率差不多。</p><p>（4）原始数组长度比较大的时候，以万为单位，这时候本地方法System.arraycopy（）方法的优势体现出来了，力压其他三种方式。</p><p>因此，需要根据操作的数组的长度，灵活地选择数组复制方式，会使得我们的程序得到性能的略微提升。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JavaSE </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数值（BigInteger与BigDecimal）</title>
      <link href="/posts/bad7d603.html"/>
      <url>/posts/bad7d603.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-大数值类简介"><a href="#1-大数值类简介" class="headerlink" title="1.大数值类简介"></a>1.大数值类简介</h2><ul><li>我们有时候会发现一些数字使用基本的数据类型已经不能满足要求，超出了精度范围，那么可以使用<code>大数值类</code>来表示数值</li><li>可以使用java.math 包中的两个很有用的类：Biglnteger 和 BigDecimaL </li><li><code>这两个类可以处理包含任意长度数字序列的数值</code>。</li><li>Biglnteger类实现了<code>任意精度的整数</code>运算</li><li>BigDecimal 实现了<code>任意精度的浮点数</code>运算。 </li></ul><h2 id="2-如何处理大数值进行计算和转换"><a href="#2-如何处理大数值进行计算和转换" class="headerlink" title="2.如何处理大数值进行计算和转换"></a>2.如何处理大数值进行计算和转换</h2><p>我们可以使用静态的 valueOf方法可以<code>将普通的数值转换为大数值</code>：<br><code>Biglnteger a = Biglnteger.valueOf(100);</code></p><ul><li>对于大数值的处理，算术运算符已经不能使用了，我们采用大数值类的方法进行加减乘除等运算</li><li>这里只介绍加减乘除，更多的方法可参考jdk</li></ul><p><strong>BigInteger:</strong><br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200415163007193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>BigDecimal</strong><br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200415163105395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JavaSE </tag>
            
            <tag> BigInteger </tag>
            
            <tag> BigDecimal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>引用传递与值传递？</title>
      <link href="/posts/255ba281.html"/>
      <url>/posts/255ba281.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-方法参数的两种类型"><a href="#1-方法参数的两种类型" class="headerlink" title="1.方法参数的两种类型"></a>1.方法参数的两种类型</h2><ul><li>形参是基本数据类型：将实参基本数据类型变量的“数据值”传递给形参</li><li>形参是引用数据类型：将实参引用数据类型变量的“地址值”传递给形参</li></ul><blockquote><p>严格点说其实只有一种：值传递。 即将实际参数(基本数据类型或引用数据类型)值的副本传入方法内，而参数本身不受影响。</p></blockquote><h2 id="2-方法参数的规则"><a href="#2-方法参数的规则" class="headerlink" title="2.方法参数的规则"></a>2.方法参数的规则</h2><ul><li>一个方法不能修改一个基本数据类型的参数（byte,short,int,long,float,double,char,boolean）</li><li>一个方法可以改变一个对象参数的状态</li><li>一个方法不能让对象引用一个新的对象</li></ul><h2 id="3-代码验证"><a href="#3-代码验证" class="headerlink" title="3.代码验证"></a>3.代码验证</h2><h3 id="3-1一个方法不能修改一个基本数据类型的参数"><a href="#3-1一个方法不能修改一个基本数据类型的参数" class="headerlink" title="3.1一个方法不能修改一个基本数据类型的参数"></a>3.1一个方法不能修改一个基本数据类型的参数</h3><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200422105221571.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>说明：</strong></p><blockquote><p>调用tripleValue这个方法之 后，percent 的值还是 10。<br>下面看一下具体的执行 过程：</p><ul><li>1 ) x 被初始化为 percent 值的一个拷贝（也就 是 10 ) </li><li>2 ) x 被乘以 3后等于 30。 但是 percent 仍然 是 10 </li><li>3 ) 这个方法结束之后，参数变量 X 不再使用。<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200422105822332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul></blockquote><h3 id="3-2一个方法可以改变一个对象参数的状态"><a href="#3-2一个方法可以改变一个对象参数的状态" class="headerlink" title="3.2一个方法可以改变一个对象参数的状态"></a>3.2一个方法可以改变一个对象参数的状态</h3><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200422110319630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>说明：</strong></p><blockquote><p>具体的执行过程为：</p><ul><li>1 ) X 被初始化为 harry 值的拷贝，这里是一个对象的引用。 </li><li>2 ) raiseSalary 方法应用于这个对象引用。x 和 harry 同时引用的那个 Employee 对象的薪金提高了 200%。 </li><li>3 ) 方法结束后，参数变量 x 不再使用。</li><li>当然，对象变量 harry 继续引用那个薪金增至 3 倍的雇员对象<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200422111030995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul></blockquote><h3 id="3-3一个方法不能让对象引用一个新的对象"><a href="#3-3一个方法不能让对象引用一个新的对象" class="headerlink" title="3.3一个方法不能让对象引用一个新的对象"></a>3.3一个方法不能让对象引用一个新的对象</h3><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200422112207577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>说明：</strong></p><blockquote><ul><li>方法并没有改变存储在变量 a 和 b 中的对象引用。</li><li>swap 方法的参数 x 和 y 被初始 化为两个对象引用的拷贝，这个方法交换的是这两个拷贝。 </li><li>在方法结束时局部变量变量 X 和 y 从栈区出栈，被丢弃了。原来的变量 a 和 b 仍然引用 这个方法调用之前所引用的对象<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200422112508900.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><p><strong>这个过程说明：</strong><code>Java 程序设计语言对对象采用的不是引用调用，实际上， 对象引用是按值传递的。</code><br>对象引用按值传递，即方法传递的是这两个对象引用的值，可以理解为地址，就像基本数据类型一样，我们不能改变着两个引用值/地址，但是我们却可以改变这两个引用值指向的对应对象的状态值</p></blockquote><h2 id="4-一个案例进一步理解方法调用"><a href="#4-一个案例进一步理解方法调用" class="headerlink" title="4.一个案例进一步理解方法调用"></a>4.一个案例进一步理解方法调用</h2><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200730112803.png" alt="image-20200730112803505"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(Value v, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        v.i = <span class="number">20</span>;</span><br><span class="line">        Value val = <span class="keyword">new</span> Value();</span><br><span class="line">        v = val;</span><br><span class="line">        System.out.println(v.i + <span class="string">" "</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">        Value v = <span class="keyword">new</span> Value();</span><br><span class="line">        v.i = <span class="number">25</span>;</span><br><span class="line">        second(v, i);</span><br><span class="line">        System.out.println(v.i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.first();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Value</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">15</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Math常用数学函数</title>
      <link href="/posts/9fbf22f0.html"/>
      <url>/posts/9fbf22f0.html</url>
      
        <content type="html"><![CDATA[<ul><li>Java 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。</li><li>Math 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。</li><li>Math类里面有两个常量e和π<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200408143530647.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200408143652896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>Math中还有许多的数学函数，这里只列取一部分，详情可参考jdk<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200408145345947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JavaSE </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>块作用域block与流程控制</title>
      <link href="/posts/5093c0c3.html"/>
      <url>/posts/5093c0c3.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-块作用域—block"><a href="#1-块作用域—block" class="headerlink" title="1.块作用域—block"></a>1.块作用域—block</h2><ul><li><code>块（即复合语句）是指由一对大括号括起来的若干条简单的 Java 语句</code>。块确定了变量的作用域。一个块可以嵌套在另一个块中，块内可以写很多语句,。</li><li><code>不能在嵌套的两个块中声明同名的变量</code>。</li><li>例如，下面的代码就有错误，而无法通过编译<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200412223608354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h2 id="2-条件语句—if-else"><a href="#2-条件语句—if-else" class="headerlink" title="2.条件语句—if/else"></a>2.条件语句—if/else</h2><ul><li>在 Java 中，条件语句的格式为：<br><code>if (condition) statement</code></li><li>条件必须用括号括起来</li></ul><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200412223810579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>在 Java 中， 更一般的条件语句格式如下所示<br><code>if (condition) statement1 else statement2</code></li><li>其中 else 部分是可选的。else 子句与最邻近的 if 构成一组<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200412224309110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200412224035550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p> <img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200412224402591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></blockquote><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200412224147443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="3-循-环"><a href="#3-循-环" class="headerlink" title="3.循 环"></a>3.循 环</h2><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><ul><li>当条件为 true 时，while 循环执行一条语句（也可以是一个语句块）。一般格式为:<br><code>while { condition ) statement</code><ul><li>如果开始循环条件的值就为 false, 则 while 循环体一次也不执行<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200412224534785.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200412224924379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul></li></ul><h3 id="do-while"><a href="#do-while" class="headerlink" title="do-while"></a>do-while</h3><ul><li>对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。</li><li>do…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">       <span class="comment">//代码语句</span></span><br><span class="line">&#125;<span class="keyword">while</span>(布尔表达式);</span><br></pre></td></tr></table></figure><blockquote><p>注意：布尔表达式在循环体的后面，所以语句块在检测布尔表达式之前已经执行了。 如果布尔表达式的值为 true，则语句块一直执行，直到布尔表达式的值为 false。</p></blockquote></li></ul><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200412225503968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="4-确定-amp-通用循环"><a href="#4-确定-amp-通用循环" class="headerlink" title="4.确定&amp;通用循环"></a>4.确定&amp;通用循环</h2><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><ul><li>虽然所有循环结构都可以用 while 或者 do…while表示，但 Java 提供了另一种语句 —— for 循环，使一些循环结构变得更加简单。</li><li>for循环执行的次数是在执行前就确定的。</li><li>for 语句的第 1 部分通常用于对计数器<code>初始化</code>；第 2 部分给出每次新一轮循环执行前要<code>检测的循环条件</code>；第 3 部分指示如何<code>更新计数器</code>。</li><li>语法格式如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化; 布尔表达式; 更新) &#123;</span><br><span class="line">    <span class="comment">//代码语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>关于 for 循环有以下几点说明：</strong></p><ul><li>最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。</li><li>然后，检测布尔表达式的值。如果为 true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。</li><li>执行一次循环后，更新循环控制变量。</li><li>再次检测布尔表达式。循环执行上面的过程。<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200412230138839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><p><strong>注意：</strong></p><ul><li>当在 for 语句的第 1 部分中声明了一个变量之后，这个变量的作用域就为 for 循环的整个循环体。</li><li>如果在 for 语句内部定义一个变量， 这个变量就不能在循环体之外使用</li></ul><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><ul><li>Java5 引入了一种主要用于数组的增强型 for 循环。</li><li>Java 增强 for 循环语法格式如下:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(声明语句 : 表达式)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//代码句子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>声明语句</code>：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。</li><li><code>表达式</code>：表达式是要访问的数组名，或者是返回值为数组的方法。<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200412230816520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h2 id="5-多重选择—switch"><a href="#5-多重选择—switch" class="headerlink" title="5.多重选择—switch"></a>5.多重选择—switch</h2><ul><li>switch case 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。</li><li>一般语句格式：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression)&#123;</span><br><span class="line">    <span class="keyword">case</span> value :</span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">case</span> value :</span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">//可选</span></span><br><span class="line">    <span class="comment">//你可以有任意数量的case语句</span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">//可选</span></span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>switch case 语句有如下规则：</strong></p><ul><li>switch 语句中的变量类型可以是： byte、short、int 或者 char。从 Java SE 7 开始，switch 支持字符串 String 类型了，同时 case 标签必须为字符串常量或字面量。</li><li>switch 语句可以拥有多个 case 语句。每个 case 后面跟一个要比较的值和冒号。</li><li>case 语句中的<code>值value的数据类型必须与变量expression的数据类型相同</code>，而且只能是常量或者字面常量。</li><li>当变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到 break 语句出现才会跳出 switch 语句。</li><li>当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含 break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句。</li><li>switch 语句可以包含一个 <code>default 分支</code>，该分支一般是 switch 语句的最后一个分支（<code>可以在任何位置，但建议在最后一个</code>）。<code>default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句</code>。</li><li>switch case 执行时，一定会先进行匹配，匹配成功返回当前 case 的值，再根据是否有 break，判断是否继续输出，或是跳出判断。</li></ul><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200412232055751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>如果 case 语句块中没有 break 语句时，JVM 并不会顺序输出每一个 case 对应的返回值，而是继续匹配，匹配不成功则返回默认 case。<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/2020041223224851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>如果 case 语句块中没有 break 语句时，匹配成功后，从当前 case 开始，后续所有 case 的值都会输出。<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200412232350833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>如果当前匹配成功的 case 语句块没有 break 语句，则从当前 case 开始，后续所有 case 的值都会输出，如果后续的 case 语句块有 break 语句则会跳出判断。<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200412232451347.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h2 id="6-中断控制流程语句"><a href="#6-中断控制流程语句" class="headerlink" title="6.中断控制流程语句"></a>6.中断控制流程语句</h2><h3 id="不带标签的break"><a href="#不带标签的break" class="headerlink" title="不带标签的break"></a>不带标签的break</h3><ul><li>break 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。</li><li>break <code>跳出最里层的循环，并且继续执行该循环下面的语句</code>。<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200412233108706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h3 id="带标签的break"><a href="#带标签的break" class="headerlink" title="带标签的break"></a>带标签的break</h3><ul><li><p>Java 提供了一种带标签的 break语句，用于<code>跳出多重嵌套的循环语句</code>。</p></li><li><p>有时候，在嵌套很深的循环语句中会发生一些不可预料的事情。此时可能更加希望跳到嵌套的所有循环语句之外。通过添加一些额外的条件判断实现各层循环的检测很不方便。</p></li><li><p>这里有一个示例说明了 break 语句的工作状态。请注意，<code>标签必须放在希望跳出的最外层循环之前， 并且必须紧跟一个冒号</code>。</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200724202200519.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><blockquote><p>事实上，可以将标签应用到任何语句中， 甚至可以应用到 if语句或者块语句中</p></blockquote><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><ul><li>continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。</li><li>在 for 循环中，continue 语句使程序立即跳转到更新语句。</li><li>在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。</li><li>简单点说，就是跳过本次循环，执行下一次循环<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200412235313606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算术运算符、自增自减运算符、关系&amp;逻辑运算符、位运算符、括号及运算符级别</title>
      <link href="/posts/48045e04.html"/>
      <url>/posts/48045e04.html</url>
      
        <content type="html"><![CDATA[<h2 id="0-思维导图"><a href="#0-思维导图" class="headerlink" title="0.思维导图"></a>0.思维导图</h2><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200729110103.png" alt="image-20200729110103144"></p><h2 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1.算术运算符"></a>1.算术运算符</h2><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>+</td><td>加</td></tr><tr><td>-</td><td>减</td></tr><tr><td>*</td><td>乘</td></tr><tr><td>/</td><td>除</td></tr><tr><td>%</td><td>求余/取模</td></tr></tbody></table><p> <img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200408141052246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2-结合赋值与运算符"><a href="#2-结合赋值与运算符" class="headerlink" title="2.结合赋值与运算符"></a>2.结合赋值与运算符</h2><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/2020040817315972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="3-自增与自减运算符"><a href="#3-自增与自减运算符" class="headerlink" title="3.自增与自减运算符"></a>3.自增与自减运算符</h2><ul><li>x为+|-</li><li>axx后缀和前缀xxa形式都会使变量值加 1 或减 1。但用在表达式中时，二者就有区别了。前缀形式会先完成加 1; 而后缀形式会使用变量原来的值。</li><li>切记不可以以纯数字来使用，比如6++就是错的<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200408174904958.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h2 id="4-关系运算符与逻辑boolean运算符"><a href="#4-关系运算符与逻辑boolean运算符" class="headerlink" title="4.关系运算符与逻辑boolean运算符"></a>4.关系运算符与逻辑boolean运算符</h2><table><thead><tr><th>符号</th><th>描述</th></tr></thead><tbody><tr><td>==</td><td>检查如果两个操作数的值是否相等，如果相等则条件为真。</td></tr><tr><td>!=</td><td>检查如果两个操作数的值是否相等，如果值不相等则条件为真。</td></tr><tr><td>&lt;</td><td>检查左操作数的值是否小于右操作数的值，如果是那么条件为真。</td></tr><tr><td>&gt;</td><td>检查左操作数的值是否大于右操作数的值，如果是那么条件为真。</td></tr><tr><td>&gt;=</td><td>检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。</td></tr><tr><td>&lt;=</td><td>检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。</td></tr><tr><td>&amp;&amp;</td><td>称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。</td></tr><tr><td>||</td><td>称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。</td></tr><tr><td>!</td><td>称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。</td></tr><tr><td>ex1?:ex2:ex3</td><td>如果ex1为true，则取ex2的值，否则取ex3的值</td></tr></tbody></table><p> <img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200408182932144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200408183011698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p> <img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200724174950589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="5-位运算符"><a href="#5-位运算符" class="headerlink" title="5.位运算符"></a>5.位运算符</h2><ul><li><p>Java定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。</p></li><li><p>位运算符作用在所有的位上，并且按位运算。</p></li><li><p>假设a = 60，b = 13;它们的二进制格式表示将如下：</p><blockquote><p>A = 0011 1100<br>B = 0000 1101<br>A&amp;B = 0000 1100<br>A | B = 0011 1101<br>A ^ B = 0011 0001<br>~A= 1100 0011</p></blockquote><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/2020072417504479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200408185241210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><h2 id="6-括号与运算符级别"><a href="#6-括号与运算符级别" class="headerlink" title="6.括号与运算符级别"></a>6.括号与运算符级别</h2><ul><li>当多个运算符出现在一个表达式中，谁先谁后呢？这就涉及到运算符的优先级别的问题。在一个多运算符的表达式中，运算符优先级不同会导致最后得出的结果差别甚大。</li><li>下表中具有<code>最高优先级的运算符在的表的最上面，最低优先级的在表的底部</code>。<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200724175216908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200408202533924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> 运算符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String-StringBuilder-StringBuffer</title>
      <link href="/posts/cbe8e8d0.html"/>
      <url>/posts/cbe8e8d0.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-字符串简介"><a href="#1-字符串简介" class="headerlink" title="1.字符串简介"></a>1.字符串简介</h2><ul><li>从概念上讲， Java 字符串就是 Unicode 字符序列。 例如， 串“ Java\u2122” 由 5 个Unicode 字符 J、a、 v、a 和™。</li><li>Java 没有内置的字符串类型， 而是在标准 Java 类库中提供了一个预定义类，很自然地叫做 String。</li><li>每个用双引号括起来的字符串都是 String类的一个实例<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200411175428894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h2 id="2-子串—substring-begin-end"><a href="#2-子串—substring-begin-end" class="headerlink" title="2.子串—substring(begin,end)"></a>2.子串—substring(begin,end)</h2><ul><li>String 类的 substring 方法可以从一个较大的字符串提取出一个子串<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200411180542424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h2 id="3-拼接—“-”"><a href="#3-拼接—“-”" class="headerlink" title="3.拼接—“+”"></a>3.拼接—“+”</h2><ul><li>Java语言允许使用 + 号连接（拼接）两个字符串。</li><li>当将一个字符串与一个非字符串的值进行拼接时，<code>后者被转换成字符串</code>，任何一个java对象都可以转换成字符串</li></ul><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200729123255.png" alt="image-20200729123253985"></p><h2 id="4-不可变字符串"><a href="#4-不可变字符串" class="headerlink" title="4.不可变字符串"></a>4.不可变字符串</h2><ul><li>String 类没有提供用于修改字符串的方法6 如果希望将 greeting=”Hello” 的内容修改为“ Help!”，不能直接地将 greeting 的最后两个位置的字符修改为‘p ’ 和‘!’</li><li>如何修改这个字符串呢？ 在 Java中实现这项操作非常容易。首先提取需要的字符， 然后再拼接上替换的字符串：</li></ul><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200411183037166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>当然，可以修改字符串变量 greeting， 让它引用另外一个字符串， 这就如同可以将存放 3 的数值变量改成存放 4 一样。但是这样效率并不高</li><li>当我们修改greeting=“Help!”时，这样做会不会产生内存遗漏呢？ 毕竞， <code>原始字符串放置在堆中</code>。十分幸运，Java 将自动地进行<code>垃圾回收</code>。 如果一块内存不再使用了， 系统最终会将其回收。</li><li>不可变字符串有一个优点：<code>编译器可以让字符串共享</code>。</li><li>可以想象将各种字符串存放在<code>公共的存储池</code>中。字符串变量指向存储池中相应的位置。如果复制一个字符串变量， 原始字符串与复制的字符串共享相同的字符。</li></ul><h2 id="5-检测字符串是否相等—equals"><a href="#5-检测字符串是否相等—equals" class="headerlink" title="5.检测字符串是否相等—equals()"></a>5.检测字符串是否相等—equals()</h2><ul><li>可以使用 equals 方法检测两个字符串是否相等。</li><li>也可以使用 if (greeti ng.compareTo(“Hel1oH) == 0} . . ,不过， 使用equals 看起来更为清晰。</li><li>要想检测两个字符串是否相等，而不区分大小写， 可以使用equalsIgnoreCase 方法。</li><li>一定不要使用=运算符检测两个字符串是否相等！ 这个运算符只能够确定两个字串是否放置在同一个位置上。当然， 如果字符串放置在同一个位置上， 它们必然相等。但是，完全有可能将内容相同的多个字符串的拷贝放置在不同的位置上。</li><li>如果虚拟机始终将相同的字符串共享， 就可以使用=运算符检测是否相等。但实际上只有字符串常量是共享的，而 + 或 substring 等操作产生的结果并不是共享的。因此，千万不要使甩== 运算符测试字符串的相等性， 以免在程序中出现糟糕的 bug。从表面上看， 这种bug 很像随机产生的间歇性错误。<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200411190645619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h2 id="6-空串与Null串"><a href="#6-空串与Null串" class="headerlink" title="6.空串与Null串"></a>6.空串与Null串</h2><ul><li><p>空串 “” 是长度为 0 的字符串。</p></li><li><p>空串是一个 Java 对象， 有自己的串长度（ 0 ) 和内容（空）。</p></li><li><p>可以调用以下代码检查一个字符串是否为空：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (str.lengthQ = <span class="number">0</span>)</span><br><span class="line">或</span><br><span class="line"><span class="keyword">if</span> (str.equals(<span class="string">""</span>))</span><br></pre></td></tr></table></figure></li><li><p>String 变量还可以存放一个特殊的值， 名为 null, 这表示目前没有任何对象与该变量关联（关于 null 的更多信息后面博文会提到)。</p></li><li><p>要检查一个字符串是否为 null, 要使用以下条件：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br></pre></td></tr></table></figure><ul><li>有时要检查一个字符串既不是 null 也不为空串，这种情况下就需要使用以下条件：</li><li>首先要检查 str 不为 null。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.lengthO != <span class="number">0</span>)</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200412002454951.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h2 id="7-码点和代码单元"><a href="#7-码点和代码单元" class="headerlink" title="7.码点和代码单元"></a>7.码点和代码单元</h2><blockquote><p><a href="https://www.jianshu.com/p/668356dd8089" target="_blank" rel="noopener">https://www.jianshu.com/p/668356dd8089</a>这篇文章对理解码点和代码单元有帮助</p></blockquote><ul><li>Java 字符串由 char 值序列组成。从 3.3.3 节“ char 类型” 已经看到， char 数据类型是一个采用 UTF-16 编码表示 Unicode 码点的代码单元。大多数的常用 Unicode 字符使用一个代码单元就可以表示，而辅助字符需要一对代码单元表示。<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200411200614186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt=" "></li><li>如果想要遍历一个字符串，并且依次査看每一个码点， 可以使用下列语句：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cp = sentence.codePointAt(i);</span><br><span class="line"><span class="keyword">if</span> (Character.isSupplementaryCodePoint(cp)) i+= <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> i++;</span><br></pre></td></tr></table></figure></li><li>可以使用下列语句实现回退操作：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i--;</span><br><span class="line"><span class="keyword">if</span> (CharacterssSurrogate(sentence.charAt(i))) i ;</span><br><span class="line"><span class="keyword">int</span> cp = sentence.codePointAt(i);</span><br></pre></td></tr></table></figure></li><li>显然， 这很麻烦。更容易的办法是使用 codePoints 方法， 它会生成一个 int 值的“ 流”，每个 int 值对应一个码点。 可以将它转换为一个数组，再完成遍历。<br><code>int[] codePoints = str.codePointsO.toArray()；</code></li><li>反之，要把一个码点数组转换为一个字符串， 可以使用构造函数<br><code>String str = new String(codePoints, 0, codePoints.length);</code></li></ul><h2 id="8-常见的String-API"><a href="#8-常见的String-API" class="headerlink" title="8.常见的String API"></a>8.常见的String API</h2><p>String类方法有很多，详情可参考API文档</p><blockquote><p><a href="http://www.matools.com/api/java8" target="_blank" rel="noopener">http://www.matools.com/api/java8</a></p></blockquote><blockquote><p><a href="https://www.runoob.com/java/java-string.html" target="_blank" rel="noopener">菜鸟教程中列举的常用String类的API方法</a></p></blockquote><h2 id="9-构建字符串—StringBuilder-amp-StringBuffer"><a href="#9-构建字符串—StringBuilder-amp-StringBuffer" class="headerlink" title="9.构建字符串—StringBuilder&amp;StringBuffer"></a>9.构建字符串—StringBuilder&amp;StringBuffer</h2><ul><li>有些时候， <code>需要由较短的字符串构建字符串</code>， 例如， 按键或来自文件中的单词。<code>采用字符串连接的方式达到此目的效率比较低</code>。每次连接字符串， 都会构建一个新的 String 对象，<code>既耗时， 又浪费空间</code>。</li><li>使用 <code>StringBuilder</code>类就可以避免这个问题的发生。</li><li>如果需要用许多小段的字符串构建一个字符串， 那么应该按照下列步骤进行。<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200412001028345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><blockquote><p>在 JDK5.0 中引入 StringBuilder 类。 这个类的前身是 StringBuffer, 其效率稍有些低， 但允许采用<code>多线程</code>的方式执行添加或删除字符的操作 , 如果所有字符串在一个单线程中编辑 （通常都是这样) ， 则应该用 StringBuilder 替代它。 <code>这两个类的 AP丨是相同的</code>。</p></blockquote></li></ul><blockquote><p><a href="https://www.runoob.com/java/java-stringbuffer.html" target="_blank" rel="noopener">菜鸟教程中StringBuilder和StringBuffer的API常用方法</a></p><ul><li>当<code>对字符串进行修改</code>的时候，需要使用 StringBuffer 和 StringBuilder 类。<br>和 String 类不同的是，<code>StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象</code>。</li><li>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。</li><li>由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
            <tag> Stringbuilder </tag>
            
            <tag> Stringbuffer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八大基本数据类型及其转换</title>
      <link href="/posts/abf8abd7.html"/>
      <url>/posts/abf8abd7.html</url>
      
        <content type="html"><![CDATA[<h2 id="0-思维导图总览"><a href="#0-思维导图总览" class="headerlink" title="0.思维导图总览"></a>0.思维导图总览</h2><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/2020031115504948.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-整型"><a href="#1-整型" class="headerlink" title="1.整型"></a>1.整型</h2><ul><li>整型用于表示没有小数部分的数值， 它允许是负数。<code>默认的整型为int型</code><br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200311155123643.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>byte 和 short 类型主要用于特定的应用场合，例如，底层的文件处理或者需要控制占用<br>存储空间量的大数组。</li><li>在 Java 中， 整型的范围与运行 Java 代码的机器无关。这就解决了软件从一个平台移植到<br>另一个平台，或者在同一个平台中的不同操作系统之间进行移植给程序员带来的诸多问题。</li><li>长整型数值有一个后缀 L 或 l ( 如 4000000000L。) </li><li>十六进制数值有一个前缀 0x 或 0X (如0xCAFEL </li><li>八进制有一个前缀 0 , 例如， 010 对应八进制中的 8。</li><li>很显然， 八进制表示法比较容易混淆， 所以建议最好不要使用八进制常数。 </li><li>从 Java 7 开始， 加上前缀 0b 或 0B 就可以写二进制数。例如，0bl001就是 9。</li><li>从 Java 7 开始，还可以为数字字面量加下划线，如用 1_000_000(或者0b1111_0100_0010_10 00_0000 )表示一百万。这些下划线只是为了让人更易读。·<code>Java 编译器会去除这些下划线</code>。</li><li>在 Java 中， 所有的数值类型所占据的字节数量与平台无关。</li><li>注意： Java 没有任何无符号（unsigned) 形式的 int、 long、short 或 byte 类型。</li><li>代码测试<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 十六进制  0x或0X都可行</span></span><br><span class="line">        <span class="keyword">int</span> a0 = <span class="number">0xa0</span>;  <span class="comment">// a0的十进制值为160</span></span><br><span class="line">        <span class="keyword">short</span> b0 = <span class="number">0Xa0</span>;</span><br><span class="line">        <span class="keyword">long</span> c0 = <span class="number">0xa0</span>;</span><br><span class="line">        <span class="keyword">byte</span> d0 = <span class="number">0X10</span>; <span class="comment">// 10对应十进制16,不能用0xa0因为超过了byte数值范围</span></span><br><span class="line">        System.out.println(a0 + <span class="string">"  "</span> + b0 + <span class="string">"  "</span> + c0 + <span class="string">"  "</span> + d0);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 八进制  0开头</span></span><br><span class="line">        <span class="keyword">int</span> a1 = <span class="number">010</span>; <span class="comment">// 10的十进制为8</span></span><br><span class="line">        <span class="keyword">short</span> b2 = <span class="number">010</span>;</span><br><span class="line">        <span class="keyword">long</span> c2 = <span class="number">010</span>;</span><br><span class="line">        <span class="keyword">byte</span> d2 = <span class="number">010</span>;</span><br><span class="line">        System.out.println(a1 + <span class="string">"  "</span> + b2 + <span class="string">"  "</span> + c2 + <span class="string">"  "</span> + d2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//二进制  0b或0B都行</span></span><br><span class="line">        <span class="keyword">int</span> a3 = <span class="number">0b100</span>; <span class="comment">// 100十进制的值为4</span></span><br><span class="line">        <span class="keyword">short</span> b3 = <span class="number">0B100</span>;</span><br><span class="line">        <span class="keyword">long</span> c3 = <span class="number">0B100</span>;</span><br><span class="line">        <span class="keyword">byte</span> d3 = <span class="number">0b100</span>;</span><br><span class="line">        System.out.println(a3 + <span class="string">"  "</span> + b3 + <span class="string">"  "</span> + c3 + <span class="string">"  "</span> + d3);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> long1 = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">long</span> long2 = <span class="number">100l</span>;</span><br><span class="line">        <span class="keyword">long</span> long3 = <span class="number">100L</span>;</span><br><span class="line">        System.out.println(long1 + <span class="string">"  "</span> + long2 + <span class="string">"  "</span> + long3);</span><br><span class="line">        <span class="comment">//从结果可以看出不加l或L对结果无影响</span></span><br><span class="line">        <span class="comment">//当数值超过int的范围时必须加上L</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//可以为数字字面量加下划线,Java 编译器会去除这些下划线</span></span><br><span class="line">        <span class="keyword">int</span> a4 = <span class="number">1____00___00</span>;</span><br><span class="line">        <span class="keyword">short</span> b4 = <span class="number">2_0_3_0</span>;</span><br><span class="line">        <span class="keyword">long</span> c4 = <span class="number">19____00</span>;</span><br><span class="line">        <span class="keyword">byte</span> d4 = <span class="number">10_1</span>;</span><br><span class="line">        System.out.println(a4 + <span class="string">"   "</span> + b4 + <span class="string">"   "</span> + c4 + <span class="string">"   "</span> + d4);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200311162756389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2-浮点型"><a href="#2-浮点型" class="headerlink" title="2.浮点型"></a>2.浮点型</h2><ul><li>浮点类型用于表示有小数部分的数值,<code>默认的浮点型为double型</code><br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200311162835476.png" alt="在这里插入图片描述"></li><li>double 表示这种类型的数值精度是 float 类型的两倍（有人称之为双精度数值)</li><li>实际上，只有很少的情况适合使用 float 类型，例如，需要单精度数据的库， 或者需要存储大量数据。</li><li>float 类型的数值有一个后缀 F 或 f (例如，3.14F。) 没有后缀 F 的浮点数值（如 3.14 ) 默认为 double 类型。</li><li>当然，也可以在浮点数值double后面添加后缀 D 或 d (例如，3.14D),不加也可以。</li><li>可以使用十六进制表示浮点数值。例如，0.125=2^-3^ 可以表示成 0x1.0p^-3^。在十六进制表示法中， 使用 p 表示指数， 而不是 e。 <code>注意， 尾数采用十六进制，指数采用十进制。指数的基数是 2，而不是 10。</code><font color=red> 对于十六进制表示我没怼出来，还请大佬多多指教，留个言教教我，抱拳了！</font></li><li>所有的浮点数值计算都遵循 <code>IEEE 754</code> 规范。具体来说，下面是用于表示<code>溢出和出错</code>情况的三个特殊的浮点数值：<br>•正无穷大<br>•负无穷大<br>•NaN (不是一个数字）<br>例如， 一 正整数除以 0 的结果为正无穷大。计算 0/0 或者负数的平方根结果为 NaN。<br>常量 <code>Double.POSITIVE_INFINITY、 Double.NEGATIVE_INFINITY 和 Double.NaN</code><br>( 以及相应的 Float 类型的常量） 分别表示<code>这三个特殊的值</code>， 但在实际应用中很少遇到。</li><li>特别要说明的是， 不能这样检测一个特定值是否等于<code>Double.NaN</code>:</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x = Double.NaN) <span class="comment">// is never true</span></span><br></pre></td></tr></table></figure><ul><li>所有“ 非数值” 的值都认为是不相同的。然而，可以使用 Double.isNaN 方法：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Double.isNaN(x)) <span class="comment">// check whether x is "not a number"</span></span><br></pre></td></tr></table></figure><ul><li><p>浮点数值<code>不适用于无法接受舍入误差的金融计算中</code>。</p></li><li><p>例如，命令 System.out.println( 2.0-1.1 ) 将打印出 0.8999999999999999, 而不是人们想象的 0.9。<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200311163957316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>这种舍入误差的主要原因是浮点数值采用二进制系统表示， 而在二进制系统中无法精确地表示分数 1/10。 这就好像十进制无法精确地表示分数 1/3—样。</p></li><li><p>如果在数值计算中<code>不允许有任何舍入误差</code>，就应该使用 BigDecimal类</p></li><li><p>代码测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> a = <span class="number">100.111f</span>;</span><br><span class="line">        <span class="keyword">float</span> b = <span class="number">100.111F</span>;</span><br><span class="line">        <span class="keyword">double</span> c = <span class="number">100.111</span>;</span><br><span class="line">        <span class="keyword">double</span> d = <span class="number">100.111</span>D;</span><br><span class="line">        <span class="keyword">double</span> e = <span class="number">100.111</span>d;</span><br><span class="line">        System.out.println(a + <span class="string">"   "</span> + b + <span class="string">"   "</span> + c + <span class="string">"   "</span> + d + <span class="string">"   "</span> + e);</span><br><span class="line">        System.out.println(Double.POSITIVE_INFINITY);</span><br><span class="line">        System.out.println(Double.NEGATIVE_INFINITY);</span><br><span class="line">        System.out.println(Double.NaN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200311175055588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><h2 id="3-char型"><a href="#3-char型" class="headerlink" title="3.char型"></a>3.char型</h2><ul><li>char 类型原本用于表示单个字符。不过，现在情况已经有所变化。 如今，有些 Unicode<br>字符可以用一个 char值描述，另外一些 Unicode 字符则需要两个 char 值。</li><li>char 类型的字面量值要用<code>单引号</code>括起来。</li><li>char a=’’，什么都不写报错，可以存个空格。</li><li>char 类型的值可以表示为十六进制值，其范围从 \u0000 到 \Uffff。例如：  \u03C0 表示希腊字母 π。</li><li>除了转义序列 \u 之外， <code>还有一些用于表示特殊字符的转义序列</code>。所有这些转义序列都可以出现在加引号的字符字面量或字符串中。例如，’\u2122’ 或 “Hello\n”。</li><li></li><li>转义序列 \u还可以出现在加引号的<code>字符常量或字符串之外</code>（而其他所有转义序列不可以）。例 如：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String\u005B\ u00SD args)</span><br></pre></td></tr></table></figure><p>就完全符合语法规则， \u005B 和 \u005D 是 [ 和 ] 的编码</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200311180337755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200311181305507.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200311181416181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>代码测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//   \u000A   asdasda</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Look inside c:\users</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200311181532607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/2020031118161161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>抱着玩的兴趣测试了一下\u转义序列</li><li>Unicode转义字符序列的官网  <a href="http://www.52unicode.com/" target="_blank" rel="noopener">http://www.52unicode.com/</a></li></ul><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200311182811687.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="4-boolean型"><a href="#4-boolean型" class="headerlink" title="4.boolean型"></a>4.boolean型</h2><ul><li>boolean (布尔）类型有两个值：<code>false 和 true</code>, 用来判定逻辑条件 整型值和布尔值之间<br>不能进行相互转换。</li></ul><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200311183101733.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="5-java内置常量对应数据类型的取值范围"><a href="#5-java内置常量对应数据类型的取值范围" class="headerlink" title="5.java内置常量对应数据类型的取值范围"></a>5.java内置常量对应数据类型的取值范围</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// byte</span></span><br><span class="line">                System.out.println(<span class="string">"基本类型：byte 二进制位数："</span> + Byte.SIZE);</span><br><span class="line">                System.out.println(<span class="string">"包装类：java.lang.Byte"</span>);</span><br><span class="line">                System.out.println(<span class="string">"最小值：Byte.MIN_VALUE="</span> + Byte.MIN_VALUE);</span><br><span class="line">                System.out.println(<span class="string">"最大值：Byte.MAX_VALUE="</span> + Byte.MAX_VALUE);</span><br><span class="line">                System.out.println();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// short</span></span><br><span class="line">                System.out.println(<span class="string">"基本类型：short 二进制位数："</span> + Short.SIZE);</span><br><span class="line">                System.out.println(<span class="string">"包装类：java.lang.Short"</span>);</span><br><span class="line">                System.out.println(<span class="string">"最小值：Short.MIN_VALUE="</span> + Short.MIN_VALUE);</span><br><span class="line">                System.out.println(<span class="string">"最大值：Short.MAX_VALUE="</span> + Short.MAX_VALUE);</span><br><span class="line">                System.out.println();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// int</span></span><br><span class="line">                System.out.println(<span class="string">"基本类型：int 二进制位数："</span> + Integer.SIZE);</span><br><span class="line">                System.out.println(<span class="string">"包装类：java.lang.Integer"</span>);</span><br><span class="line">                System.out.println(<span class="string">"最小值：Integer.MIN_VALUE="</span> + Integer.MIN_VALUE);</span><br><span class="line">                System.out.println(<span class="string">"最大值：Integer.MAX_VALUE="</span> + Integer.MAX_VALUE);</span><br><span class="line">                System.out.println();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// long</span></span><br><span class="line">                System.out.println(<span class="string">"基本类型：long 二进制位数："</span> + Long.SIZE);</span><br><span class="line">                System.out.println(<span class="string">"包装类：java.lang.Long"</span>);</span><br><span class="line">                System.out.println(<span class="string">"最小值：Long.MIN_VALUE="</span> + Long.MIN_VALUE);</span><br><span class="line">                System.out.println(<span class="string">"最大值：Long.MAX_VALUE="</span> + Long.MAX_VALUE);</span><br><span class="line">                System.out.println();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// float</span></span><br><span class="line">                System.out.println(<span class="string">"基本类型：float 二进制位数："</span> + Float.SIZE);</span><br><span class="line">                System.out.println(<span class="string">"包装类：java.lang.Float"</span>);</span><br><span class="line">                System.out.println(<span class="string">"最小值：Float.MIN_VALUE="</span> + Float.MIN_VALUE);</span><br><span class="line">                System.out.println(<span class="string">"最大值：Float.MAX_VALUE="</span> + Float.MAX_VALUE);</span><br><span class="line">                System.out.println();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// double</span></span><br><span class="line">                System.out.println(<span class="string">"基本类型：double 二进制位数："</span> + Double.SIZE);</span><br><span class="line">                System.out.println(<span class="string">"包装类：java.lang.Double"</span>);</span><br><span class="line">                System.out.println(<span class="string">"最小值：Double.MIN_VALUE="</span> + Double.MIN_VALUE);</span><br><span class="line">                System.out.println(<span class="string">"最大值：Double.MAX_VALUE="</span> + Double.MAX_VALUE);</span><br><span class="line">                System.out.println();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// char</span></span><br><span class="line">                System.out.println(<span class="string">"基本类型：char 二进制位数："</span> + Character.SIZE);</span><br><span class="line">                System.out.println(<span class="string">"包装类：java.lang.Character"</span>);</span><br><span class="line">                <span class="comment">// 以数值形式而不是字符形式将Character.MIN_VALUE输出到控制台</span></span><br><span class="line">                System.out.println(<span class="string">"最小值：Character.MIN_VALUE="</span></span><br><span class="line">                        + (<span class="keyword">int</span>) Character.MIN_VALUE);</span><br><span class="line">                <span class="comment">// 以数值形式而不是字符形式将Character.MAX_VALUE输出到控制台</span></span><br><span class="line">                System.out.println(<span class="string">"最大值：Character.MAX_VALUE="</span></span><br><span class="line">                        + (<span class="keyword">int</span>) Character.MAX_VALUE);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/2020031119152014.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="6-数据类型默认值"><a href="#6-数据类型默认值" class="headerlink" title="6.数据类型默认值"></a>6.数据类型默认值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> bool;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span> by;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> d;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">float</span> f;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> l;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">short</span> sh;</span><br><span class="line">    <span class="keyword">static</span> String str;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Bool :"</span> + bool);</span><br><span class="line">        System.out.println(<span class="string">"Byte :"</span> + by);</span><br><span class="line">        System.out.println(<span class="string">"Character:"</span> + ch);</span><br><span class="line">        System.out.println(<span class="string">"Double :"</span> + d);</span><br><span class="line">        System.out.println(<span class="string">"Float :"</span> + f);</span><br><span class="line">        System.out.println(<span class="string">"Integer :"</span> + i);</span><br><span class="line">        System.out.println(<span class="string">"Long :"</span> + l);</span><br><span class="line">        System.out.println(<span class="string">"Short :"</span> + sh);</span><br><span class="line">        System.out.println(<span class="string">"String :"</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200311191720101.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="7-数值类型之间的转换"><a href="#7-数值类型之间的转换" class="headerlink" title="7.数值类型之间的转换"></a>7.数值类型之间的转换</h2><h3 id="（1）定义数据类型后自动转换"><a href="#（1）定义数据类型后自动转换" class="headerlink" title="（1）定义数据类型后自动转换"></a>（1）定义数据类型后自动转换</h3><ul><li>数值类型之间的转换就是自动将一种数据类型转换成另一种数据类型</li><li>数值类型之间自动转换时的表：<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200408153958379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JavaSE.Chapter3.Section35.cs352;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">mains</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*可能会出现信息丢失的转换情况*/</span></span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">1234567899</span>;</span><br><span class="line">    <span class="keyword">long</span> b=<span class="number">1234567891234567891L</span>;</span><br><span class="line">    <span class="keyword">float</span> fa=a,fb=b;<span class="comment">//单精度浮点型只保留8位小数</span></span><br><span class="line">    <span class="keyword">double</span> da=a,db=b;    <span class="comment">//双精度浮点型只保留16位小数</span></span><br><span class="line">    System.out.println(fa);</span><br><span class="line">    System.out.println(fb);</span><br><span class="line">    System.out.println(da);</span><br><span class="line">    System.out.println(db);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*不会出现信息丢失的转换情况*/</span></span><br><span class="line">        <span class="keyword">byte</span> b1=<span class="number">123</span>;</span><br><span class="line">        <span class="keyword">short</span> s1=b1;</span><br><span class="line">        <span class="keyword">int</span> i1=b1;</span><br><span class="line">        <span class="keyword">long</span> l1=b1;</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(i1);</span><br><span class="line">        System.out.println(l1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">short</span> s2=<span class="number">12345</span>;</span><br><span class="line">        <span class="keyword">int</span> i2=s2;</span><br><span class="line">        <span class="keyword">long</span> l2=s2;</span><br><span class="line">        System.out.println(i2);</span><br><span class="line">        System.out.println(l2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i3=<span class="number">1234567891</span>;</span><br><span class="line">        <span class="keyword">long</span> l3=i3;</span><br><span class="line">        <span class="keyword">double</span> d3=i3;</span><br><span class="line">        System.out.println(l3);</span><br><span class="line">        System.out.println(d3);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> c1=<span class="string">'A'</span>;</span><br><span class="line">        <span class="keyword">int</span> i4=c1;</span><br><span class="line">        System.out.println(i4);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> f1=<span class="number">123.12345f</span>;</span><br><span class="line">        <span class="keyword">double</span> d4=f1;</span><br><span class="line">        System.out.println(f1);</span><br><span class="line">        System.out.println(d4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/2020040816310291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>这里浮点型取值范围与计算机组成原理里面讲的IEEE754标准有关</li></ul><h3 id="（2）二元运算时的自动转换"><a href="#（2）二元运算时的自动转换" class="headerlink" title="（2）二元运算时的自动转换"></a>（2）二元运算时的自动转换</h3><ul><li>此外两种不同类型的数据进行二元运算时，比如加减乘除，数据转换从位数少的数据类型向位数多的数据类型转换，然后再进行二元运算。</li><li>比如char是1个字节，int是4个字节，char+int，两种数据类型相加，得到的是一个整数。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch2=<span class="string">'A'</span>;</span><br><span class="line">      <span class="keyword">int</span>  i=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">double</span> d1=<span class="number">100.11</span>d;</span><br><span class="line">      System.out.println(ch2+i);</span><br><span class="line">      System.out.println(d1+i);</span><br><span class="line">      System.out.println(d1+ch2);</span><br></pre></td></tr></table></figure></li></ul><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200408164202519.png" alt="在这里插入图片描述"></p><h3 id="（3）强制类型转换"><a href="#（3）强制类型转换" class="headerlink" title="（3）强制类型转换"></a>（3）强制类型转换</h3><ul><li>比如说将double转换为int型，即不按照上面所提到的转换表表进行合法转换</li><li>强制类型转换将小数部分截去，将浮点值转换为整型值</li></ul><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200408170650185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>如果试图将一个数值从一种类型强制转换为另一种类型， 而又超出了目标类型的表示范围，结果就会截断成一个完全不同的值<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200408171338790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>不要将boolean与其它数据类型进行转换</li><li>可以用条件转换<code>x? 1:0</code>代替</li></ul><h2 id="8-参考"><a href="#8-参考" class="headerlink" title="8.参考"></a>8.参考</h2><ul><li><a href="https://www.runoob.com/java/java-basic-datatypes.html" target="_blank" rel="noopener">https://www.runoob.com/java/java-basic-datatypes.html</a></li><li>《java核心技术卷一第十版》</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装jdk配置环境、cmd命令行运行java程序、安装IDEA编写代码测试</title>
      <link href="/posts/c3aae306.html"/>
      <url>/posts/c3aae306.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-安装jdk配置环境"><a href="#1-安装jdk配置环境" class="headerlink" title="1.安装jdk配置环境"></a>1.安装jdk配置环境</h2><ul><li>首先打开官网Oracle <a href="https://www.oracle.com/java/technologies/javase-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase-downloads.html</a><br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200308130724110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200308130803535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>下载完毕到本地安装，配置环境变量JAVA_HOME和Path<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200308131449239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200308131009983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200308131112644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200308131125210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200308132105618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200308132229797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><ul><li>cmd测试是否配置成功</li><li>window+R<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/2020030813240593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>有下图上的信息则代表配置环境变量正确<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200308132505607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul></li></ul><h2 id="2-cmd命令行测试环境变量配置是否正确及运行java程序"><a href="#2-cmd命令行测试环境变量配置是否正确及运行java程序" class="headerlink" title="2.cmd命令行测试环境变量配置是否正确及运行java程序"></a>2.cmd命令行测试环境变量配置是否正确及运行java程序</h2><ul><li><p>首先我们建立一个A.text文件夹，然后修改后缀为java。改为A.java文件</p></li><li><p>可能有时候电脑默认不会显示后缀名可以修改一下系统设置，就可以看见后缀名进行更改了<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200308133239941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>A.java中写入测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Hello World !"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>再次打开cmd，找到A.java目录<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200308134024335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>测试A.java代码</p></li><li><p>首先javac 先编译A.java源代码文件，生成A.class字节码文件</p></li><li><p>再用java虚拟机运行A.class 字节码文件<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200308134924270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><h2 id="3-安装IDEA编写代码测试"><a href="#3-安装IDEA编写代码测试" class="headerlink" title="3.安装IDEA编写代码测试"></a>3.安装IDEA编写代码测试</h2><ul><li>打开IDEA官网下载界面 <a href="https://www.jetbrains.com/idea/download" target="_blank" rel="noopener">https://www.jetbrains.com/idea/download</a><br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200308135801256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>然后点击安装包安装就可以了<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200308135953484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>后续步骤都默认next</li><li>现在我们来新建一个文件来测试java代码<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200308140320218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200308140425338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200308140453319.png" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200308140520801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200308141122409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200308141324993.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200308141352871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> IDEA </tag>
            
            <tag> CMD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaSE、JavaEE、JavaME、jdk、jre、jvm、java主要的11个特性</title>
      <link href="/posts/42a4578.html"/>
      <url>/posts/42a4578.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-JavaSE、JavaEE、JavaME是什么？"><a href="#1-JavaSE、JavaEE、JavaME是什么？" class="headerlink" title="1.JavaSE、JavaEE、JavaME是什么？"></a>1.JavaSE、JavaEE、JavaME是什么？</h2><ul><li>JavaSE（J2SE）（Java2 Platform Standard Edition，java平台标准版）</li><li>JavaEE(J2EE)(Java 2 Platform,Enterprise Edition，java平台企业版)</li><li>JavaME(J2ME)(Java 2 Platform Micro Edition，java平台微型版)。</li><li>Java SE是标准版，包含标准的JVM和标准库</li><li>Java EE是企业版，在Java SE的基础上加上了大量的API和库，以便方便开发Web应用、数据库、消息服务等，Java EE的应用使用的虚拟机和Java SE完全相同。</li><li>Java ME和Java SE不同，它是一个针对嵌入式设备的“瘦身版”，Java SE的标准库无法在Java ME上使用，Java ME的虚拟机也是“瘦身版”。<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200308230636304.png" alt="在这里插入图片描述"></li><li>Java大致学习方向如下：</li></ul><ol><li>首先要学习Java SE，掌握Java语言本身、Java核心开发技术以及Java标准库的使用；</li><li>如果继续学习Java EE，那么Spring框架、数据库开发、分布式架构就是需要学习的；</li><li>如果要学习大数据开发，那么Hadoop、Spark、Flink这些大数据平台就是需要学习的，他们都基于Java或Scala开发；</li><li>如果想要学习移动开发，那么就深入Android平台，掌握Android App开发。</li></ol><ul><li>无论怎么选择，Java SE的核心技术是基础，必须学好！</li></ul><h2 id="2-jdk、jre、jvm是什么？"><a href="#2-jdk、jre、jvm是什么？" class="headerlink" title="2.jdk、jre、jvm是什么？"></a>2.jdk、jre、jvm是什么？</h2><ul><li>JDK：Java Development Kit 是针对Java开发员的产品，是整个Java的核心，包括了Java运行环境<br>JRE、Java工具和Java基础类库。</li><li>JRE：Java Runtime Environment 是运行JAVA程序所必须的环境的集合，包含JVM标准实现及Java核心类库。</li><li>JVM：Java Virtual Machine （Java虚拟机）的缩写，是整个java实现跨平台的最核心的部分，能够运行以Java语言编写的软件程序。</li><li>来自oracle官方的结构图，jvm虚拟机在最底层。<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/2020030823200043.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>一个java程序的执行过程，首先jdk中的编译器javac将源代码编译成字节码class文件，然后jre中的java虚拟机jvm执行字节码文件class运行程序。<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200308231749362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h2 id="3-java主要的11个特性"><a href="#3-java主要的11个特性" class="headerlink" title="3.java主要的11个特性"></a>3.java主要的11个特性</h2><ul><li><p>Java语言是简单的：<br>Java语言的语法与C语言和C++语言很接近，使得大多数程序员很容易学习和使用。另一方面，Java丢弃了C++中很少使用的、很难理解的、令人迷惑的那些特性，如操作符重载、多继承、自动的强制类型转换。特别地，Java语言不使用指针，而是引用。并提供了自动的废料收集，使得程序员不必为内存管理而担忧。</p></li><li><p>Java语言是面向对象的：<br>Java语言提供类、接口和继承等面向对象的特性，为了简单起见，只支持类之间的单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制（关键字为implements）。Java语言全面支持动态绑定，而C++语言只对虚函数使用动态绑定。总之，Java语言是一个纯的面向对象程序设计语言。</p></li><li><p>Java语言是分布式的：<br>Java语言支持Internet应用的开发，在基本的Java应用编程接口中有一个网络应用编程接口（java net），它提供了用于网络应用编程的类库，包括URL、URLConnection、Socket、ServerSocket等。Java的RMI（远程方法激活）机制也是开发分布式应用的重要手段。</p></li><li><p>Java语言是健壮的：<br>Java的强类型机制、异常处理、垃圾的自动收集等是Java程序健壮性的重要保证。对指针的丢弃是Java的明智选择。Java的安全检查机制使得Java更具健壮性。</p></li><li><p>Java语言是安全的：<br>Java通常被用在网络环境中，为此，Java提供了一个安全机制以防恶意代码的攻击。除了Java语言具有的许多安全特性以外，Java对通过网络下载的类具有一个安全防范机制（类ClassLoader），如分配不同的名字空间以防替代本地的同名类、字节代码检查，并提供安全管理机制（类SecurityManager）让Java应用设置安全哨兵。</p></li><li><p>Java语言是体系结构中立的：<br>Java程序（后缀为java的文件）在Java平台上被编译为体系结构中立的字节码格式（后缀为class的文件），然后可以在实现这个Java平台的任何系统中运行。这种途径适合于异构的网络环境和软件的分发。</p></li><li><p>Java语言是可移植的：<br>这种可移植性来源于体系结构中立性，另外，Java还严格规定了各个基本数据类型的长度。Java系统本身也具有很强的可移植性，Java编译器是用Java实现的，Java的运行环境是用ANSI C实现的。</p></li><li><p>Java语言是解释型的：<br>如前所述，Java程序在Java平台上被编译为字节码格式，然后可以在实现这个Java平台的任何系统中运行。在运行时，Java平台中的Java解释器对这些字节码进行解释执行，执行过程中需要的类在联接阶段被载入到运行环境中。</p></li><li><p>Java是高性能的：<br>与那些解释型的高级脚本语言相比，Java的确是高性能的。事实上，Java的运行速度随着JIT(Just-In-Time）编译器技术的发展越来越接近于C++。</p></li><li><p>Java语言是多线程的：<br>在Java语言中，线程是一种特殊的对象，它必须由Thread类或其子（孙）类来创建。通常有两种方法来创建线程：其一，使用型构为Thread(Runnable)的构造子类将一个实现了Runnable接口的对象包装成一个线程，其二，从Thread类派生出子类并重写run方法，使用该子类创建的对象即为线程。值得注意的是Thread类已经实现了Runnable接口，因此，任何一个线程均有它的run方法，而run方法中包含了线程所要运行的代码。线程的活动由一组方法来控制。Java语言支持多个线程的同时执行，并提供多线程之间的同步机制（关键字为synchronized）。</p></li><li><p>Java语言是动态的：<br>Java语言的设计目标之一是适应于动态变化的环境。Java程序需要的类能够动态地被载入到运行环境，也可以通过网络来载入所需要的类。这也有利于软件的升级。另外，Java中的类有一个运行时刻的表示，能进行运行时刻的类型检查。</p></li></ul><p>参考：</p><ul><li>《java核心技术卷一原书第10版》</li><li>《head first java》</li><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255876875896416" target="_blank" rel="noopener">廖雪峰的官方网站</a></li><li><a href="https://www.runoob.com/java/java-intro.html" target="_blank" rel="noopener">菜鸟教程</a></li><li><a href="https://docs.oracle.com/javase/8/docs/" target="_blank" rel="noopener">Oracl官网</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概述：标识符、访问修饰符、变量、数组、枚举、注释、空行、继承、接口、（对象、类、方法、实例变量）、关键字表</title>
      <link href="/posts/5812e9ad.html"/>
      <url>/posts/5812e9ad.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-标识符"><a href="#1-标识符" class="headerlink" title="1.标识符"></a>1.标识符</h2><p>Java 所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。</p><p>关于 Java 标识符，有以下几点需要注意：</p><ul><li>所有的标识符都应该以字母（A-Z 或者 a-z）,美元符（$）、或者下划线（_）<code>开始</code></li><li>首字符<code>之后</code>可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（_）或数字的任何字符组合</li><li>关键字不能用作标识符</li><li>标识符是大小写敏感的</li><li>合法标识符举例：age、$salary、_value、__1_value</li><li>非法标识符举例：123abc、-salary</li></ul><h2 id="2-标识符命名规范"><a href="#2-标识符命名规范" class="headerlink" title="2.标识符命名规范"></a>2.标识符命名规范</h2><p>编写 Java 程序时，应注意以下几点：</p><ul><li>大小写敏感：Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。</li><li>类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz ，<code>驼峰命名法</code>。</li><li>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz</li><li>源文件名：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存，文件名的后缀为 .java。</li><li>常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ</li><li>主方法入口：所有的 Java 程序由 public static void main(String []args) 方法开始执行。</li><li>包名：多单词组成时所有字母都小写：xxxyyyzzz</li></ul><h2 id="3-访问修饰符"><a href="#3-访问修饰符" class="headerlink" title="3.访问修饰符"></a>3.访问修饰符</h2><p>像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：</p><ul><li>访问控制修饰符 : default, public , protected, private</li><li>非访问控制修饰符 : final, abstract, static, synchronized</li></ul><h2 id="4-变量"><a href="#4-变量" class="headerlink" title="4.变量"></a>4.变量</h2><p> <strong>变量的概念：</strong></p><ul><li>内存中的一个存储区域</li><li>该区域的数据可以在同一类型范围内不断变化</li><li>变量是程序中最基本的存储单元。包含变量类型、变量名和存储的值</li></ul><p><strong>变量的作用：</strong></p><ul><li>用于在内存中保存数据</li></ul><p><strong>使用变量注意：</strong></p><ul><li><p>Java中每个变量必须先声明，后使用</p></li><li><p>使用变量名来访问这块区域的数据</p></li><li><p>变量的作用域：其定义所在的一对{ }内</p></li><li><p>变量只有在其作用域内才有效</p></li><li><p>同一个作用域内，不能定义重名的变量</p></li></ul><p><strong>声明变量：</strong><br>语法：&lt;数据类型&gt; &lt;变量名称&gt;<br>例如：int var;</p><p><strong>变量的赋值</strong><br> 语法：&lt;变量名称&gt; = &lt;值&gt;<br> 例如：var = 10;</p><p><strong>声明和赋值变量</strong><br>语法： &lt;数据类型&gt; &lt;变量名&gt; = &lt;初始化值&gt;<br>例如：int var = 10;</p><p><strong>变量的分类- 按数据类型：</strong></p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200724173603447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200724173713517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200730103212.png" alt="image-20200730103212337"></p><p> <strong>类变量、成员变量和局部变量内存分析：</strong></p><ol><li><p>类变量(静态变量)：用static修饰的变量称为静态变量，其内容被该类的所有对象共享，<strong>所有对象中这个类变量的值都指向相同的一处内存</strong>，随便一个对象修改了此处内存的值都会影响其他对象。</p></li><li><p>成员变量：在类定义时声明的变量，随着对象的建立而建立，随着对象的消失而消失，存在于对象所在的<strong>堆内存</strong>中。</p></li><li><p>局部变量：在函数中声明的变量，只定义在局部范围内，只在所属的区域有效。存在于<strong>栈内存</strong>中，作用的范围结束，栈帧释放，变量就消失。</p></li></ol><h2 id="5-数组"><a href="#5-数组" class="headerlink" title="5.数组"></a>5.数组</h2><ul><li>数组是储存在<code>堆</code>上的<code>对象</code>，可以保存多个同类型变量。数组名引用是存在栈区，实际new分配的内存在堆区。</li></ul><h2 id="6-枚举"><a href="#6-枚举" class="headerlink" title="6. 枚举"></a>6. 枚举</h2><ul><li>Java 5.0引入了枚举，枚举限制变量只能是预先设定好的值。使用枚举可以减少代码中的 bug。</li><li>注意：<code>枚举可以单独声明或者声明在类里面 。方法、变量、构造函数也可以在枚举中定义</code>。</li><li>例如，我们为果汁店设计一个程序，它将限制果汁为小杯、中杯、大杯。这就意味着它不允许顾客点除了这三种尺寸外的果汁。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FreshJuice</span> </span>&#123;</span><br><span class="line">   <span class="keyword">enum</span> FreshJuiceSize&#123; SMALL, MEDIUM , LARGE &#125;</span><br><span class="line">   FreshJuiceSize size;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FreshJuiceTest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">      FreshJuice juice = <span class="keyword">new</span> FreshJuice();</span><br><span class="line">      juice.size = FreshJuice.FreshJuiceSize.MEDIUM  ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-注释"><a href="#7-注释" class="headerlink" title="7.注释"></a>7.注释</h2><ul><li>类似于 C/C++、Java 也支持单行以及多行注释。注释中的字符将被 Java 编译器忽略。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">   <span class="comment">/* 这是第一个Java程序</span></span><br><span class="line"><span class="comment">    *它将打印Hello World</span></span><br><span class="line"><span class="comment">    * 这是一个多行注释的示例</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">       <span class="comment">// 这是单行注释的示例</span></span><br><span class="line">       <span class="comment">/* 这个也是单行注释的示例 */</span></span><br><span class="line">       System.out.println(<span class="string">"Hello World"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-空行"><a href="#8-空行" class="headerlink" title="8.空行"></a>8.空行</h2><ul><li>空白行或者有注释的行，Java 编译器都会忽略掉。</li></ul><h2 id="9-继承"><a href="#9-继承" class="headerlink" title="9.继承"></a>9.继承</h2><ul><li><p>在 Java 中，一个类可以由其他类派生。如果你要创建一个类，而且已经存在一个类具有你所需要的属性或方法，那么你可以将新创建的类继承该类。</p></li><li><p>利用继承的方法，可以重用已存在类的方法和属性，而不用重写这些代码。<code>被继承的类称为超类（super class），派生类称为子类（subclass）</code>。</p></li></ul><h2 id="10-接口"><a href="#10-接口" class="headerlink" title="10.接口"></a>10.接口</h2><ul><li>在 Java 中，<code>接口可理解为对象间相互通信的协议</code>。接口在继承中扮演着很重要的角色。</li><li><code>接口只定义派生要用到的方法，但是方法的具体实现完全取决于派生类</code>。</li></ul><h2 id="11-对象、类、方法、实例"><a href="#11-对象、类、方法、实例" class="headerlink" title="11.对象、类、方法、实例"></a>11.对象、类、方法、实例</h2><ul><li>一个 Java 程序可以认为是一系列对象的集合，而这些对象通过调用彼此的方法来协同工作。下面简要介绍下类、对象、方法和实例变量的概念。</li><li>对象：<code>对象是类的一个实例</code>，有状态和行为，状态即属性，行为即方法。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</li><li>类：<code>类是一个模板，它描述一类对象的行为和状态</code>,它具有属性、构造器、普通方法、或代码块。</li><li>实例变量：非static修饰的变量，在类的内部，方法外部的变量。</li><li>方法：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。<code>方法通过方法名被调用，且只有被调用才会执行。</code></li></ul><p>方法调用的过程分析:</p><p><img src= "/img/loading.gif" data-src="https://image.bithachi.cn/20200730103612.png" alt="image-20200730103612875"></p><h2 id="12-关键字表"><a href="#12-关键字表" class="headerlink" title="12.关键字表"></a>12.关键字表</h2><ul><li>下面列出了 Java 关键字。这些保留字不能用于常量、变量、和任何标识符的名称。</li></ul><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200724172810844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200724172821303.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="13-保留字-reserved-word"><a href="#13-保留字-reserved-word" class="headerlink" title="13.保留字(reserved word)"></a>13.保留字(reserved word)</h2><ul><li>现有Java版本尚未使用，但以后版本可能会作为关键字使<br>用。自己命名标识符时要避免使用这些保留字<br><code>goto 、const</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射详解</title>
      <link href="/posts/6e3bcb10.html"/>
      <url>/posts/6e3bcb10.html</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>Java的反射机制是Java特性之一，反射机制是构建框架技术的基础所在。灵活掌握Java反射机制，对以后学习框架技术有很大的帮助。</li><li>本篇文章用到的代码在我的github上面：<a href="https://github.com/BitHachi/Java_core_book/tree/master/src/JavaSE/Chapter5/Section57" target="_blank" rel="noopener">BitHachi/JJava_core_book/tree/master/src/JavaSE/Chapter5/Section57</a>。<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200722195924629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul></blockquote><h1 id="1-什么是Java的反射呢？"><a href="#1-什么是Java的反射呢？" class="headerlink" title="1.什么是Java的反射呢？"></a>1.什么是Java的反射呢？</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大家都知道，要让Java程序能够运行，那么就得让Java类要被Java虚拟机加载。Java类如果不被Java虚拟机加载，是不能正常运行的。现在我们运行的所有的程序都是在编译期的时候就已经知道了你所需要的那个类的已经被加载了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java的反射机制是在编译并不确定是哪个类被加载了，而是在程序运行的时候才加载、探知、自审。使用在编译期并不知道的类。这样的特点就是反射。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。</p><h1 id="2-Java反射有什么作用呢？"><a href="#2-Java反射有什么作用呢？" class="headerlink" title="2.Java反射有什么作用呢？"></a>2.Java反射有什么作用呢？</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假如我们有两个程序员，一个程序员在写程序的时候，需要使用第二个程序员所写的类，但第二个程序员并没完成他所写的类。那么第一个程序员的代码能否通过编译呢？这是不能通过编译的。利用Java反射的机制，就可以让第一个程序员在没有得到第二个程序员所写的类的时候，来完成自身代码的编译。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Java的反射机制它知道类的基本结构，这种对Java类结构探知的能力，我们称为Java类的“自审”。</code>大家都用过IDEA和eclipse。当我们构建出一个对象的时候，去调用该对象的方法和属性的时候。一按点，编译工具就会自动的把该对象能够使用的所有的方法和属性全部都列出来，供用户进行选择。这就是利用了Java反射的原理，是对我们创建对象的探知、自审。(反射是一种功能强大且复杂的机制。使用它的主要人员是工具构造者，而不是应用程序员。)</p><h1 id="3-Class类"><a href="#3-Class类" class="headerlink" title="3.Class类"></a>3.Class类</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要正确使用Java反射机制就得使用java.lang.Class这个类。它是Java反射机制的起源。当一个类被加载以后，Java虚拟机就会自动产生一个Class对象。通过这个Class对象我们就能获得加载到虚拟机当中这个Class对象对应的方法、成员变量以及构造方法的声明和定义等信息。</p><h1 id="4-获取class类对象"><a href="#4-获取class类对象" class="headerlink" title="4.获取class类对象"></a>4.获取class类对象</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;既然class对象如此重要，那么我们如何获取class对象呢？这里有三种方法： </p><h2 id="4-1-使用类对象的getClass-方法"><a href="#4-1-使用类对象的getClass-方法" class="headerlink" title="4.1  使用类对象的getClass()方法"></a>4.1  使用类对象的getClass()方法</h2><ul><li><p>使用类对象的getClass()方法<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200721223506271.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="4-2-Class-forName-classname"><a href="#4-2-Class-forName-classname" class="headerlink" title="4.2 Class.forName(classname)"></a>4.2 Class.forName(classname)</h2></li><li><p>使用 Class.forName(classname) 静态方法。当你知道该类的全路径名时，你可以使用该方法获取 Class 类对象</p></li><li><p>如果className不是类名或接口名，则forname抛出一个checked exception异常所以应该给这个方法提供一个异常处理器</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200721224056665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="4-3-class-方法"><a href="#4-3-class-方法" class="headerlink" title="4.3 .class 方法"></a>4.3 .class 方法</h2></li></ul><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200721224339711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="5-通过反射创建类对象"><a href="#5-通过反射创建类对象" class="headerlink" title="5.通过反射创建类对象"></a>5.通过反射创建类对象</h1><ul><li>既然通过上文我们知道了如何获取class对象，那么我们是不是就可以根据这个类对象来创建实例对象呢？当然可以</li><li>通过反射创建类对象主要有两种方式：通过 Class 对象的 newInstance() 方法、通过 Constructor 对象的 newInstance() 方法。<h2 id="5-1-Class-对象的-newInstance-方法"><a href="#5-1-Class-对象的-newInstance-方法" class="headerlink" title="5.1 Class 对象的 newInstance() 方法"></a>5.1 Class 对象的 newInstance() 方法</h2></li><li>newlnstance方法调用默认的构造器（没有参数的构造器）初始化新创建的对象。如果这个类没有默认的构造器， 就会抛出一个异常。<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200721230954365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h2 id="5-2-Constructor-对象的-newInstance-方法"><a href="#5-2-Constructor-对象的-newInstance-方法" class="headerlink" title="5.2  Constructor 对象的 newInstance() 方法"></a>5.2  Constructor 对象的 newInstance() 方法</h2><ul><li>通过 Constructor 对象创建类对象可以选择特定构造方法，而通过 Class 对象则只能使用默认的无参数构造方法。</li><li>这里getConstructor和newInstance使用时需要设置异常处理，我这里是直接在main后面throws了<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200721231841616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h1 id="6-获取类属性、方法、构造器的结构"><a href="#6-获取类属性、方法、构造器的结构" class="headerlink" title="6.获取类属性、方法、构造器的结构"></a>6.获取类属性、方法、构造器的结构</h1><ul><li>我们已经成功获取了class类对象，并学会了如何创建对象，现在我们还可以看看对象内部的结构是什么样的，比如属性、方法和构造器。</li><li>在java.lang.reflect 包中有三个类 Field、Method 和 Constructor分别用于描述类的属性、 方法和构造器<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br></pre></td></tr></table></figure></li></ul><p><strong>下面介绍一下 Field、Method 和 Constructor三个类的常用方法</strong></p><ul><li>Field类的getType 方法， 用来返回属性所属类型的 Class 对象</li><li>Method 类有一个getReturnType方法，返回return值所属类型的Class对象</li><li>Method 和 Constructor 类有一个共同的方法getParameterTypes，返回方法参数所属类型的Class对象</li><li>Field、Method 和 Constructor都有一个getName 方法，返回方法名的字符串</li><li>Field、Method 和 Constructor都有一个getModifiers方法，它将返回一个整型数值，用不同的位开关描述 public 和 static 这样 的修饰符使用状况。可以利用 Modifier.toString方法将 修饰符打印出来。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Method m : methods) &#123;</span><br><span class="line">String modifiers = Modifier.toString(m.getModifiers());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>该修饰符是java.lang.reflect.Modifier的静态属性。这里是用十进制表示的，源码里面是十六进制表示的。<br>对应表如下：<br>PUBLIC: 1<br>PRIVATE: 2<br>PROTECTED: 4<br>STATIC: 8<br>FINAL: 16<br>SYNCHRONIZED: 32<br>VOLATILE: 64<br>TRANSIENT: 128<br>NATIVE: 256<br>INTERFACE: 512<br>ABSTRACT: 1024<br>STRICT: 2048</p></blockquote><ul><li>可以使用Modifiei类中的 isPublic、 isPrivate 或 isFinal 判断方法或构造器是否是 public、 private 或 final</li><li>Class类中的 getFields、 getMethods 和 getConstructors方 法将 分 别 返 回 类 提 供 的 所有public 属性、 方法和构造器数组， 其中<code>包括超类的公有成员</code>。</li><li>Class 类的 getDeclareFields、 getDeclareMethods 和getDeclaredConstructors方法将分别返回类中声明的全部属性、 方法和构 造器， 其中包括private和protected成员，但<code>不包括超类的成员</code>。</li></ul><p><strong>下面是一个代码案例,显示了如何打印一个类的全部信息的方法。<br>这个程序提醒用户输入一个类名，然后输出类中所有的属性、方法、构造器。里面有一些数字是我用来测试，类似-m8-</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JavaSE.Chapter5.Section57.cs573;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program uses reflection to print all features of a class.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Cay Horstmann</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.1 2004-02-21</span></span><br><span class="line"><span class="comment"> * 利用反射分析类的能力，查看属性、构造器、方法的结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           String name = <span class="string">"JavaSE.Chapter5.Section57.cs571.Employee"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取输入字符串的类对象</span></span><br><span class="line">            Class cl = Class.forName(name);</span><br><span class="line">            System.out.println(cl + <span class="string">"-1-"</span>);</span><br><span class="line">            <span class="comment">//获取父类对象</span></span><br><span class="line">            Class supercl = cl.getSuperclass();</span><br><span class="line">            System.out.println(supercl + <span class="string">"-2-"</span>);</span><br><span class="line">            <span class="comment">//获取类的访问修饰符和属于public、private、还是final</span></span><br><span class="line">            String modifiers = Modifier.toString(cl.getModifiers());</span><br><span class="line">            System.out.println(cl.getModifiers() + <span class="string">"-----cl.getModifiers"</span>);</span><br><span class="line">            System.out.println(modifiers + <span class="string">"-4-"</span>);</span><br><span class="line">            <span class="keyword">if</span> (modifiers.length() &gt; <span class="number">0</span>) System.out.print(modifiers + <span class="string">" "</span>);</span><br><span class="line">            System.out.print(<span class="string">"class "</span> + name);</span><br><span class="line">            if (supercl != null &amp;&amp; supercl != Object.class) System.out.print(" extends "</span><br><span class="line">                    + supercl.getName());</span><br><span class="line"></span><br><span class="line">            System.out.print(<span class="string">"\n&#123;\n"</span>);</span><br><span class="line">            System.out.println(<span class="string">"------------打印构造器方法-----------"</span>);</span><br><span class="line">            printConstructors(cl);</span><br><span class="line">            System.out.println(<span class="string">"------------打印非构造器方法-----------"</span>);</span><br><span class="line">            printMethods(cl);</span><br><span class="line">            System.out.println(<span class="string">"------------打印属性信息-----------"</span>);</span><br><span class="line">            printFields(cl);</span><br><span class="line">            System.out.println(<span class="string">"&#125;"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Prints all constructors of a class</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cl a class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printConstructors</span><span class="params">(Class cl)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*返回反映Constructor对象表示的类声明的所有Constructor对象的数组类 。</span></span><br><span class="line"><span class="comment">         这些是public，protected，default（package）访问和私有构造函数。</span></span><br><span class="line"><span class="comment">         返回的数组中的元素不会排序，并且不是任何特定的顺序。</span></span><br><span class="line"><span class="comment">         如果类有一个默认构造函数，它将包含在返回的数组中。</span></span><br><span class="line"><span class="comment">         如果类对象表示接口，原始类型，数组类或空值，则此方法返回长度为0的数组。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Constructor[] constructors = cl.getDeclaredConstructors();</span><br><span class="line">        System.out.println(Arrays.toString(constructors) + <span class="string">"-c5-"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Constructor c : constructors) &#123;</span><br><span class="line">            String name = c.getName();</span><br><span class="line">            System.out.print(<span class="string">"   "</span>);</span><br><span class="line">            String modifiers = Modifier.toString(c.getModifiers());</span><br><span class="line">            System.out.println(c.getModifiers() + <span class="string">"-----Counstructor.getModifiers"</span>);</span><br><span class="line">            <span class="comment">//打印构造方法的访问修饰符</span></span><br><span class="line">            <span class="keyword">if</span> (modifiers.length() &gt; <span class="number">0</span>) System.out.print(modifiers + <span class="string">" "</span>);</span><br><span class="line">            <span class="comment">//打印构造方法的名字</span></span><br><span class="line">            System.out.print(name + <span class="string">"("</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取类构造器的参数类型数组</span></span><br><span class="line">            Class[] paramTypes = c.getParameterTypes();</span><br><span class="line">            System.out.println(<span class="string">"-6-"</span> + Arrays.toString(paramTypes) + <span class="string">"-c6-"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; paramTypes.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) System.out.print(<span class="string">", "</span>);</span><br><span class="line">                <span class="comment">//打印参数类型名字</span></span><br><span class="line">                System.out.print(paramTypes[j].getName());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">");"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Prints all methods of a class</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cl a class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMethods</span><span class="params">(Class cl)</span> </span>&#123;</span><br><span class="line">        Method[] methods = cl.getDeclaredMethods();</span><br><span class="line">        System.out.println(Arrays.toString(methods) + <span class="string">"-m7-"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Method m : methods) &#123;</span><br><span class="line">            Class retType = m.getReturnType();</span><br><span class="line">            System.out.println(retType + <span class="string">"-m8-"</span>);</span><br><span class="line">            String name = m.getName();</span><br><span class="line"></span><br><span class="line">            System.out.print(<span class="string">"   "</span>);</span><br><span class="line">            <span class="comment">// print modifiers, return type and method name</span></span><br><span class="line">            String modifiers = Modifier.toString(m.getModifiers());</span><br><span class="line">            System.out.println(m.getModifiers() + <span class="string">"-----Method.getModifiers"</span>);</span><br><span class="line">            <span class="comment">//打印方法的访问修饰符</span></span><br><span class="line">            <span class="keyword">if</span> (modifiers.length() &gt; <span class="number">0</span>) System.out.print(modifiers + <span class="string">" "</span>);</span><br><span class="line">            <span class="comment">//打印方法返回类型和方法名</span></span><br><span class="line">            System.out.print(retType.getName() + <span class="string">" "</span> + name + <span class="string">"("</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// print parameter types</span></span><br><span class="line">            Class[] paramTypes = m.getParameterTypes();</span><br><span class="line">            System.out.println(<span class="string">"-m9-"</span> + Arrays.toString(paramTypes) + <span class="string">"-m9-"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; paramTypes.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) System.out.print(<span class="string">", "</span>);</span><br><span class="line">                <span class="comment">//打印方法参数类型</span></span><br><span class="line">                System.out.print(paramTypes[j].getName());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">");"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Prints all fields of a class</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cl a class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFields</span><span class="params">(Class cl)</span> </span>&#123;</span><br><span class="line">        Field[] fields = cl.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f : fields) &#123;</span><br><span class="line">            Class type = f.getType();<span class="comment">//返回属性所属类型的 Class 对象</span></span><br><span class="line">            System.out.println(type + <span class="string">"-f10-"</span>);</span><br><span class="line">            String name = f.getName();</span><br><span class="line">            System.out.print(<span class="string">"   "</span>);</span><br><span class="line">            String modifiers = Modifier.toString(f.getModifiers());</span><br><span class="line">            System.out.println(f.getModifiers() + <span class="string">"-----Field.getModifiers"</span>);</span><br><span class="line">            <span class="comment">//打印属性的访问修饰符</span></span><br><span class="line">            <span class="keyword">if</span> (modifiers.length() &gt; <span class="number">0</span>) System.out.print(modifiers + <span class="string">" "</span>);</span><br><span class="line">            <span class="comment">//打印属性的类型名和属性名字</span></span><br><span class="line">            System.out.println(type.getName() + <span class="string">" "</span> + name + <span class="string">";"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200722195702267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200722195718811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200722195729203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="7-获取或设置类对象的属性值"><a href="#7-获取或设置类对象的属性值" class="headerlink" title="7.获取或设置类对象的属性值"></a>7.获取或设置类对象的属性值</h1><ul><li>在编写程序时， 如果知道想要査看的属性和类型，查看指定的属性值是一件很容易的事情。而利用反射机制可以查看在编译时还不清楚的属性值。</li><li><code>Class t = f.getType();</code>//获取属性类型,f为Field对象。</li><li>我们可以用<code>f.get(obj)</code>获取 obj 属性的当前值。f为Field对象，obj是一个Object对象。</li><li>可以获得就可以设置。调用<code>f.set(obj，value)</code>可以将 obj 对象的 f 属性设置成新值。f为Field对象。<ul><li>（1）如果我们要查看某个private属性的值，由于受限于java的访问机制，我们需要调用Field、Method 或 Constructor 对象的 setAccessible 方法，来设置private的值的可访问性，<code>x. setAccessible(true);</code>，x为Field、Method 或 Constructor的对象。<br>（2）也可以使用<code>AccessibleObject.setAccessible(x, true);</code>来设置private值的可访问性，它是 Field、 Method 和 Constructor 类的公共超类，x为Field、Method 或 Constructor 对象的数组引用。</li></ul></li></ul><p><strong>接下来的一个例子将使用上面所说的方法，来查看访问对象的属性值</strong></p><p>如下一个可供任意类使用的通用 toString方法。 其中使用 getDeclaredFileds 获得所有的数据属性， 然后使用 setAccessible 将所有的属性设置为可访问的。 对于每个属性，获得了名字和值。递归调用 toString方法，将每个值转换成字符串。(这个例子是java核心技术卷一里面的，这个例子看懂我感觉还是需要花时间的，有的地方我还没看懂……)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JavaSE.Chapter5.Section57.cs574;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> JavaSE.Chapter5.Section57.cs571.Employee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在运行时使用反射分析对象，查看对象当前的各个属性值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectAnalyzerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, NoSuchFieldException, InstantiationException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Employee s = <span class="keyword">new</span> Employee();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> ObjectAnalyzer().toString(s));</span><br><span class="line">        System.out.println(<span class="string">"--------------------------------"</span>);</span><br><span class="line">        String[] str = &#123;<span class="string">"str11"</span>, <span class="string">"str22"</span>, <span class="string">"str33"</span>&#125;;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> ObjectAnalyzer().toString(str));</span><br><span class="line">        System.out.println(<span class="string">"--------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        Class em = s.getClass();</span><br><span class="line">        Object obj = em.newInstance();</span><br><span class="line">        Field f = em.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object val = f.get(obj);<span class="comment">//获取属性的值</span></span><br><span class="line">        System.out.println(val);</span><br><span class="line">        f.set(obj, <span class="string">"BitHachi"</span>);</span><br><span class="line">        Employee em2 = (Employee) obj;</span><br><span class="line">        System.out.println(em2.getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JavaSE.Chapter5.Section57.cs574;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.AccessibleObject;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectAnalyzer</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> ArrayList&lt;Object&gt; visited = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (obj == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">"null"</span>;</span><br><span class="line">      <span class="keyword">if</span> (visited.contains(obj)) <span class="keyword">return</span> <span class="string">"..."</span>;</span><br><span class="line">      visited.add(obj);</span><br><span class="line">      Class cl = obj.getClass();</span><br><span class="line">      <span class="comment">//如果对象是一个字符串对象，则直接打印其值</span></span><br><span class="line">      <span class="keyword">if</span> (cl == String<span class="class">.<span class="keyword">class</span>) <span class="title">return</span> (<span class="title">String</span>) <span class="title">obj</span></span>;</span><br><span class="line">      <span class="comment">//判断类对象是否是一个数组</span></span><br><span class="line">      <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">         <span class="comment">//getComponentType返回对象数组的的Class类对象。 如果此类不表示数组类，则此方法返回null。</span></span><br><span class="line">         String r = cl.getComponentType() + <span class="string">"[]&#123;"</span>;</span><br><span class="line">         System.out.println(r + <span class="string">"-1-"</span>);</span><br><span class="line">         <span class="comment">//返回指定数组对象的长度Array.getLength(obj)</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Array.getLength(obj); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) r += <span class="string">","</span>;</span><br><span class="line">            <span class="comment">//返回指定数组对象中的索引组件的值。</span></span><br><span class="line">            Object val = Array.get(obj, i);</span><br><span class="line">            System.out.println(val + <span class="string">" -val -2-"</span>);</span><br><span class="line">            <span class="comment">/*确定指定类对象表示一个基本类型。</span></span><br><span class="line"><span class="comment">            有九个预定类对象代表八个原始类型和void。</span></span><br><span class="line"><span class="comment">            这些是由Java虚拟机创建，并且具有相同的名称为他们所代表的基本类型，</span></span><br><span class="line"><span class="comment">            即boolean ， byte ， char ， short ， int ， long ， float和double 。</span></span><br><span class="line"><span class="comment">            isPrimitive返回一个boolean值*/</span></span><br><span class="line">            <span class="keyword">if</span> (cl.getComponentType().isPrimitive()) r += <span class="string">"@"</span> + val + <span class="string">"@"</span>;</span><br><span class="line">            <span class="keyword">else</span> r += toString(val);</span><br><span class="line">            System.out.println(r + <span class="string">"-3-"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> r + <span class="string">"&#125;"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      String r = cl.getName();</span><br><span class="line">      System.out.println(r + <span class="string">"-4-"</span>);</span><br><span class="line">      <span class="comment">// 检查此类和所有超类的字段</span></span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">         r += <span class="string">"["</span>;</span><br><span class="line">         <span class="comment">//获取类的所有属性得一个数组</span></span><br><span class="line">         Field[] fields = cl.getDeclaredFields();</span><br><span class="line">         <span class="comment">/*setAccessible()为反射对象设置可访问标志。 true 表明屏蔽 Java语言的访问检查，</span></span><br><span class="line"><span class="comment">         使得对象的 private私有属性也可以被査询和设置。 */</span></span><br><span class="line">         AccessibleObject.setAccessible(fields, <span class="keyword">true</span>);</span><br><span class="line">         <span class="comment">//获取所有属性的名字和值</span></span><br><span class="line">         <span class="keyword">for</span> (Field f : fields) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isStatic(f.getModifiers())) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!r.endsWith(<span class="string">"["</span>)) r += <span class="string">","</span>;</span><br><span class="line">               r += f.getName() + <span class="string">"="</span>;</span><br><span class="line">               System.out.println(r + <span class="string">"-5-"</span>);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                  Class t = f.getType();<span class="comment">//获取属性类型</span></span><br><span class="line">                  Object val = f.get(obj);<span class="comment">//获取属性的值</span></span><br><span class="line">                  System.out.println(val + <span class="string">" -val -6-"</span>);</span><br><span class="line">                  <span class="keyword">if</span> (t.isPrimitive()) &#123;</span><br><span class="line">                     r += val;</span><br><span class="line">                     System.out.println(r + <span class="string">"-7-"</span>);</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     r += toString(val);</span><br><span class="line">                     System.out.println(r + <span class="string">"-7-"</span>);</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">               &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         r += <span class="string">"]"</span>;</span><br><span class="line">         cl = cl.getSuperclass();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (cl != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> r;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200722195249588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="8-利用反射调用任意方法"><a href="#8-利用反射调用任意方法" class="headerlink" title="8.利用反射调用任意方法"></a>8.利用反射调用任意方法</h1><ul><li>反射机制可以允许调用任意的方法</li><li>在Method类中有一个invoke方法，它可以允许调用包装在Method对象中的方法</li></ul><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200722202224750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200722202235180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>下面是一个代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JavaSE.Chapter5.Section57.cs576;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodTableTest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">// 获取相应方法的Method对象，通过类对象来获取方法对象</span></span><br><span class="line">      Method square = MethodTableTest.class.getMethod("square", double.class);</span><br><span class="line">      Method sqrt = Math.class.getMethod("sqrt", double.class);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 打印x和y值表</span></span><br><span class="line">      printTable(<span class="number">1</span>, <span class="number">10</span>, <span class="number">10</span>, square);</span><br><span class="line">      printTable(<span class="number">1</span>, <span class="number">10</span>, <span class="number">10</span>, sqrt);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> x * x;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Prints a table with x- and y-values for a method</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> from the lower bound for the x-values 上限</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> to   the upper bound for the x-values  下限</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> n    the number of rows in the table   个数</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> f    a method with a double parameter and double return value</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTable</span><span class="params">(<span class="keyword">double</span> from, <span class="keyword">double</span> to, <span class="keyword">int</span> n, Method f)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// print out the method as table header</span></span><br><span class="line">      System.out.println(<span class="string">"方法： "</span> + f);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">double</span> dx = (to - from) / (n - <span class="number">1</span>);<span class="comment">//按上下限设置每次加的值</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">double</span> x = from; x &lt;= to; x += dx) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> y = (Double) f.invoke(<span class="keyword">null</span>, x);<span class="comment">//调用这个方法对象进行计算</span></span><br><span class="line">            System.out.printf(<span class="string">"%10.4f | %10.4f%n"</span>, x, y);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/2020072220232476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="9-使用反射编写泛型数组代码，复制数组"><a href="#9-使用反射编写泛型数组代码，复制数组" class="headerlink" title="9. 使用反射编写泛型数组代码，复制数组"></a>9. 使用反射编写泛型数组代码，复制数组</h1><ul><li>我们可以利用反射来扩充一个数组的容量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JavaSE.Chapter5.Section57.cs575;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOfTest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">      a = (<span class="keyword">int</span>[]) goodCopyOf(a, <span class="number">10</span>);</span><br><span class="line">      System.out.println(Arrays.toString(a));</span><br><span class="line">      System.out.println(<span class="string">"--------------------"</span>);</span><br><span class="line">      String[] b = &#123;<span class="string">"Tom"</span>, <span class="string">"Dick"</span>, <span class="string">"Harry"</span>&#125;;</span><br><span class="line">      b = (String[]) goodCopyOf(b, <span class="number">10</span>);</span><br><span class="line">      System.out.println(Arrays.toString(b));</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">goodCopyOf</span><span class="params">(Object a, <span class="keyword">int</span> newLength)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//第一步：获取a数组的类对象</span></span><br><span class="line">      Class cl = a.getClass();</span><br><span class="line">      System.out.println(cl + <span class="string">"---1"</span>);</span><br><span class="line">      <span class="comment">//第二步：判断a数组的类对象是否是一个数组</span></span><br><span class="line">      <span class="keyword">if</span> (!cl.isArray()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//第三步：使用Class类的getComponentType方法确定数组对应的类型</span></span><br><span class="line">      Class componentType = cl.getComponentType();</span><br><span class="line">      System.out.println(componentType + <span class="string">"---2"</span>);</span><br><span class="line">      <span class="comment">//获取数组的长度</span></span><br><span class="line">      <span class="keyword">int</span> length = Array.getLength(a);</span><br><span class="line">      System.out.println(length + <span class="string">"---3"</span>);</span><br><span class="line">      <span class="comment">//构造新数组newInstance方法</span></span><br><span class="line">      <span class="comment">//返回一个具有给定类型、给定长度的新数组</span></span><br><span class="line">      Object newArray = Array.newInstance(componentType, newLength);</span><br><span class="line">      <span class="comment">/*arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</span></span><br><span class="line"><span class="comment">      将指定源数组中的数组从指定位置复制到目标数组的指定位置。*/</span></span><br><span class="line">      System.arraycopy(a, <span class="number">0</span>, newArray, <span class="number">0</span>, Math.min(length, newLength));</span><br><span class="line">      <span class="keyword">return</span> newArray;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/2020072220285340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="10-可以用-比较两个Class对象"><a href="#10-可以用-比较两个Class对象" class="headerlink" title="10. 可以用==比较两个Class对象"></a>10. 可以用==比较两个Class对象</h1><ul><li>虚拟机为每个类型管理一个 Class 对象。因此， 可以利用== 运算符实现两个类对象比较的操作。 例如:</li></ul><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200617213040641.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="11-收获与感受"><a href="#11-收获与感受" class="headerlink" title="11.收获与感受"></a>11.收获与感受</h1><ul><li>反射里面用到了多态的特性，这一点真的很重要，特别是Object与其它对象之间的互转，不懂得话，很容易懵圈</li><li>4-8的应用是反射里面的核心点，当然还有很多的API没办法一次性讲完，其实只要懂了核心的部分，其它的API就比较好懂了</li><li>关于反射的内容和应用还有很多，以后在工作中遇到了相关内容再进行补充叭，现在作为初学者，先总结整理这么多叭。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html#%E5%8F%8D%E5%B0%84%E5%B8%B8%E7%94%A8api" target="_blank" rel="noopener">https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html#%E5%8F%8D%E5%B0%84%E5%B8%B8%E7%94%A8api</a></li><li><a href="https://www.iteye.com/blog/762626559-qq-com-395402" target="_blank" rel="noopener">https://www.iteye.com/blog/762626559-qq-com-395402</a></li><li><a href="https://blog.csdn.net/qq_40434646/article/details/82351488" target="_blank" rel="noopener">https://blog.csdn.net/qq_40434646/article/details/82351488</a></li><li><a href="https://blog.csdn.net/kjfcpua/article/details/8496911" target="_blank" rel="noopener">https://blog.csdn.net/kjfcpua/article/details/8496911</a></li><li><a href="http://yuncode.net/code/c_56768be18995515" target="_blank" rel="noopener">http://yuncode.net/code/c_56768be18995515</a></li><li><a href="https://www.cnblogs.com/fengmao/p/8609855.html" target="_blank" rel="noopener">https://www.cnblogs.com/fengmao/p/8609855.html</a></li><li><a href="https://www.cnblogs.com/daimajun/p/6545533.html" target="_blank" rel="noopener">https://www.cnblogs.com/daimajun/p/6545533.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《MySQL必知必会》所有SQL语句图表集合（可作为查询表使用）---持续更新</title>
      <link href="/posts/dfcd7c37.html"/>
      <url>/posts/dfcd7c37.html</url>
      
        <content type="html"><![CDATA[<ul><li>本篇文章是对《MySQL必知必会》所有语句知识点的图表集合，适合快速查询遗忘的SQL语句，<code>原创不易，转载请注明出处</code>。</li><li>本文的脉络结构，首先先给出《MySQL必知必会》的目录，有一个全局的认识，方便查找，然后依次列出三张表。</li><li>SQL语句图表集合总共分为三张，<code>第一张</code>的内容是书中3-13章的内容，<code>第二张</code>是14-22章的内容，<code>第三张</code>是23-30章的内容，希望对大家学习MySQL的SQL语句有所帮助叭！</li></ul><h1 id="1-《MySQL必知必会》目录"><a href="#1-《MySQL必知必会》目录" class="headerlink" title="1.《MySQL必知必会》目录"></a>1.《MySQL必知必会》目录</h1><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200721140609365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200721140403664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200721140427144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200721140449494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200721140510256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="2-第一张"><a href="#2-第一张" class="headerlink" title="2.第一张"></a>2.第一张</h1><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200721141746353.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内部类详解(使用场景和好处、相关内部类的笔试面试题)</title>
      <link href="/posts/bf7b3e18.html"/>
      <url>/posts/bf7b3e18.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>此篇文章作者为：Matrix海子　　　　<br>出处：<a href="http://www.cnblogs.com/dolphin0520/" target="_blank" rel="noopener">http://www.cnblogs.com/dolphin0520/</a></p></blockquote><p>最近也是在学习java，看的是《java核心技术卷一》jdk8，看到内部类的知识点有一点模糊不清，偶然间看到作者写的这篇文章，把我在书中没有完全理解和疑惑的地方全讲清楚了，虽然关于字节码那部分对我这个初学者来说有一些参数看不懂，但是大致通过作者的叙述和自己的思考，可以理解大部分，相信对我以后学习jvm会很有帮助，能看到这篇文章，万分荣幸，感谢作者的心血付出，膜拜。</p><p><strong>进入正文：</strong><br>说起内部类这个词，想必很多人都不陌生，但是又会觉得不熟悉。原因是平时编写代码时可能用到的场景不多，用得最多的是在有事件监听的情况下，并且即使用到也很少去总结内部类的用法。今天我们就来一探究竟。</p><h1 id="1-内部类基础"><a href="#1-内部类基础" class="headerlink" title="1.内部类基础"></a>1.内部类基础</h1><p>在Java中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。广泛意义上的内部类一般来说包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类。下面就先来了解一下这四种内部类的用法。</p><h2 id="1-1-成员内部类"><a href="#1-1-成员内部类" class="headerlink" title="1.1 成员内部类"></a>1.1 成员内部类</h2><p>　　成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius = <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Draw</span> </span>&#123;     <span class="comment">//内部类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSahpe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"drawshape"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样看起来，类Draw像是类Circle的一个成员，Circle称为外部类。成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count =<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Draw</span> </span>&#123;     <span class="comment">//内部类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSahpe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(radius);  <span class="comment">//外部类的private成员</span></span><br><span class="line">            System.out.println(count);   <span class="comment">//外部类的静态成员</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">外部类.<span class="keyword">this</span>.成员变量</span><br><span class="line">外部类.<span class="keyword">this</span>.成员方法</span><br></pre></td></tr></table></figure><p>虽然成员内部类可以无条件地访问外部类的成员，而外部类想访问成员内部类的成员却不是这么随心所欲了。在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">        getDrawInstance().drawSahpe();   <span class="comment">//必须先创建成员内部类的对象，再进行访问</span></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Draw <span class="title">getDrawInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Draw();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Draw</span> </span>&#123;     <span class="comment">//内部类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSahpe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(radius);  <span class="comment">//外部类的private成员</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="comment">//第一种方式：</span></span><br><span class="line">        Outter outter = <span class="keyword">new</span> Outter();</span><br><span class="line">        Outter.Inner inner = outter.<span class="keyword">new</span> Inner();  <span class="comment">//必须通过Outter对象来创建</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//第二种方式：</span></span><br><span class="line">        Outter.Inner inner1 = outter.getInnerInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Inner inner = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner <span class="title">getInnerInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inner == <span class="keyword">null</span>)</span><br><span class="line">            inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        <span class="keyword">return</span> inner;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。比如上面的例子，如果成员内部类Inner用private修饰，则只能在外部类的内部访问，如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。这一点和外部类有一点不一样，外部类只能被public和包访问两种权限修饰。我个人是这么理解的，由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰。</p><blockquote><p>这里插入作者当时版本没有考虑到的一个问题：<br>“<code>局部内部类和匿名内部类</code>只能访问局部final变量”<br>从JDK 1.8开始，会默认给这两种内部类访问的field 加上final(隐式地)，所以你可能会在编译器中看到可以访问没有加final的变量，只有你去<code>修改</code>它时，编译器才会<code>报错</code>。</p></blockquote><h2 id="1-2-局部内部类"><a href="#1-2-局部内部类" class="headerlink" title="1.2 局部内部类"></a>1.2 局部内部类</h2><p>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Man</span><span class="params">()</span></span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> People <span class="title">getWoman</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123;   <span class="comment">//局部内部类</span></span><br><span class="line">            <span class="keyword">int</span> age =<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Woman();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。</p><h2 id="1-3-匿名内部类"><a href="#1-3-匿名内部类" class="headerlink" title="1.3 匿名内部类"></a>1.3 匿名内部类</h2><p>匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。下面这段代码是一段Android事件监听代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">scan_bt.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">             </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">                 </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">         </span><br><span class="line">        history_bt.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">             </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">                 </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>这段代码为两个按钮设置监听器，这里面就使用了匿名内部类。这段代码中的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">             </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">                 </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>就是匿名内部类的使用。代码中需要给按钮设置监听器对象，使用匿名内部类能够在实现父类或者接口中的方法情况下同时产生一个相应的对象，但是前提是这个父类或者接口必须先存在才能这样使用。当然像下面这种写法也是可以的，跟上面使用匿名内部类达到效果相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setListener</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    scan_bt.setOnClickListener(<span class="keyword">new</span> Listener1());       </span><br><span class="line">    history_bt.setOnClickListener(<span class="keyword">new</span> Listener2());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Listener1</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">             </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Listener2</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">             </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法虽然能达到一样的效果，但是既冗长又难以维护，所以一般使用匿名内部类的方法来编写事件监听代码。同样的，匿名内部类也是不能有访问修饰符和static修饰符的。</p><p>　　匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为Outter$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。</p><h2 id="1-4-静态内部类"><a href="#1-4-静态内部类" class="headerlink" title="1.4 静态内部类"></a>1.4 静态内部类</h2><p>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        Outter.Inner inner = <span class="keyword">new</span> Outter.Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200720231313280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="2-深入理解内部类"><a href="#2-深入理解内部类" class="headerlink" title="2.深入理解内部类"></a>2.深入理解内部类</h1><h2 id="2-1-为什么成员内部类可以无条件访问外部类的成员？"><a href="#2-1-为什么成员内部类可以无条件访问外部类的成员？" class="headerlink" title="2.1 为什么成员内部类可以无条件访问外部类的成员？"></a>2.1 为什么成员内部类可以无条件访问外部类的成员？</h2><p>　　在此之前，我们已经讨论过了成员内部类可以无条件访问外部类的成员，那具体究竟是如何实现的呢？下面通过反编译字节码文件看看究竟。事实上，编译器在进行编译的时候，会将成员内部类单独编译成一个字节码文件，下面是Outter.java的代码：　　</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Inner inner = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner <span class="title">getInnerInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inner == <span class="keyword">null</span>)</span><br><span class="line">            inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        <span class="keyword">return</span> inner;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译之后，出现了两个字节码文件：</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200720231435730.png" alt="在这里插入图片描述"></p><p>反编译Outter$Inner.class文件得到下面信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">E:\Workspace\Test\bin\com\cxh\test2&gt;javap -v Outter$Inner</span><br><span class="line">Compiled from <span class="string">"Outter.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">cxh</span>.<span class="title">test2</span>.<span class="title">Outter</span>$<span class="title">Inner</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span></span></span><br><span class="line">  SourceFile: "Outter.java"</span><br><span class="line">  InnerClass:</span><br><span class="line">   #24= #1 of #22; //Inner=class com/cxh/test2/Outter$Inner of class com/cxh/tes</span><br><span class="line">t2/Outter</span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">50</span></span><br><span class="line">  Constant pool:</span><br><span class="line">const #1 = class        #2;     //  com/cxh/test2/Outter$Inner</span><br><span class="line">const #2 = Asciz        com/cxh/test2/Outter$Inner;</span><br><span class="line">const #3 = class        #4;     //  java/lang/Object</span><br><span class="line">const #4 = Asciz        java/lang/Object;</span><br><span class="line">const #5 = Asciz        this$0;</span><br><span class="line">const #6 = Asciz        Lcom/cxh/test2/Outter;;</span><br><span class="line">const #7 = Asciz        &lt;init&gt;;</span><br><span class="line">const #8 = Asciz        (Lcom/cxh/test2/Outter;)V;</span><br><span class="line">const #9 = Asciz        Code;</span><br><span class="line">const #10 = Field       #1.#11; //  com/cxh/test2/Outter$Inner.this$0:Lcom/cxh/t</span><br><span class="line">est2/Outter;</span><br><span class="line">const #11 = NameAndType #5:#6;//  this$0:Lcom/cxh/test2/Outter;</span><br><span class="line">const #12 = Method      #3.#13; //  java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">const #13 = NameAndType #7:#14;//  "&lt;init&gt;":()V</span><br><span class="line">const #14 = Asciz       ()V;</span><br><span class="line">const #15 = Asciz       LineNumberTable;</span><br><span class="line">const #16 = Asciz       LocalVariableTable;</span><br><span class="line">const #17 = Asciz       this;</span><br><span class="line">const #18 = Asciz       Lcom/cxh/test2/Outter$Inner;;</span><br><span class="line">const #19 = Asciz       SourceFile;</span><br><span class="line">const #20 = Asciz       Outter.java;</span><br><span class="line">const #21 = Asciz       InnerClasses;</span><br><span class="line">const #22 = class       #23;    //  com/cxh/test2/Outter</span><br><span class="line">const #23 = Asciz       com/cxh/test2/Outter;</span><br><span class="line">const #24 = Asciz       Inner;</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">final</span> com.cxh.test2.Outter <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> com.cxh.test2.Outter$Inner(com.cxh.test2.Outter);</span><br><span class="line">  Code:</span><br><span class="line">   Stack=<span class="number">2</span>, Locals=<span class="number">2</span>, Args_size=<span class="number">2</span></span><br><span class="line">   <span class="number">0</span>:   aload_0</span><br><span class="line">   <span class="number">1</span>:   aload_1</span><br><span class="line">   2:   putfield        #10; //Field this$0:Lcom/cxh/test2/Outter;</span><br><span class="line">   <span class="number">5</span>:   aload_0</span><br><span class="line">   6:   invokespecial   #12; //Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   <span class="number">9</span>:   <span class="keyword">return</span></span><br><span class="line">  LineNumberTable:</span><br><span class="line">   line <span class="number">16</span>: <span class="number">0</span></span><br><span class="line">   line <span class="number">18</span>: <span class="number">9</span></span><br><span class="line"> </span><br><span class="line">  LocalVariableTable:</span><br><span class="line">   Start  Length  Slot  Name   Signature</span><br><span class="line">   <span class="number">0</span>      <span class="number">10</span>      <span class="number">0</span>    <span class="keyword">this</span>       Lcom/cxh/test2/Outter$Inner;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第11行到35行是常量池的内容，下面逐一第38行的内容：<br><code>final com.cxh.test2.Outter this$0;</code></p><p>　这行是一个指向外部类对象的指针，看到这里想必大家豁然开朗了。也就是说编译器会默认为成员内部类添加了一个指向外部类对象的引用，那么这个引用是如何赋初值的呢？下面接着看内部类的构造器：<br>　<br><code>public com.cxh.test2.Outter$Inner(com.cxh.test2.Outter);</code></p><p>从这里可以看出，虽然我们在定义的内部类的构造器是无参构造器，编译器还是会默认添加一个参数，该参数的类型为指向外部类对象的一个引用，所以成员内部类中的Outter this&amp;0 指针便指向了外部类对象，因此可以在成员内部类中随意访问外部类的成员。从这里也间接说明了成员内部类是依赖于外部类的，如果没有创建外部类的对象，则无法对Outter this&amp;0引用进行初始化赋值，也就无法创建成员内部类的对象了。</p><h2 id="2-2-为什么局部内部类和匿名内部类只能访问局部final变量？"><a href="#2-2-为什么局部内部类和匿名内部类只能访问局部final变量？" class="headerlink" title="2.2 为什么局部内部类和匿名内部类只能访问局部final变量？"></a>2.2 为什么局部内部类和匿名内部类只能访问局部final变量？</h2><p>想必这个问题也曾经困扰过很多人，在讨论这个问题之前，先看下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码会被编译成两个class文件：Test.class和Test1.class。默认情况下，编译器会为匿名内部类和局部内部类起名为Outterx.class（x为正整数）。</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200720231625870.png" alt="在这里插入图片描述"></p><p>根据上图可知，test方法中的匿名内部类的名字被起为 Test$1。</p><p>　　上段代码中，如果把变量a和b前面的任一个final去掉，这段代码都编译不过。我们先考虑这样一个问题：</p><p>　　当test方法执行完毕之后，变量a的生命周期就结束了，而此时Thread对象的生命周期很可能还没有结束，那么在Thread的run方法中继续访问变量a就变成不可能了，但是又要实现这样的效果，怎么办呢？Java采用了 <code>复制</code>  的手段来解决这个问题。将这段代码的字节码反编译可以得到下面的内容：</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/2020072023164318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>我们看到在run方法中有一条指令：</p><p><code>bipush 10</code></p><p>这条指令表示将操作数10压栈，表示使用的是一个本地局部变量。这个过程是在编译期间由编译器默认进行，如果这个变量的值在编译期间可以确定，则编译器默认会在匿名内部类（局部内部类）的常量池中添加一个内容相等的字面量或直接将相应的字节码嵌入到执行字节码中。这样一来，匿名内部类使用的变量是另一个局部变量，只不过值和方法中局部变量的值相等，因此和方法中的局部变量完全独立开。</p><p><strong>下面再看一个例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译得到：</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200720231732185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们看到匿名内部类Test$1的构造器含有两个参数，一个是指向外部类对象的引用，一个是int型变量，很显然，这里是将变量test方法中的形参a以参数的形式传进来对匿名内部类中的拷贝（变量a的拷贝）进行赋值初始化。</p><p>　<code>也就说如果局部变量的值在编译期间就可以确定，则直接在匿名内部里面创建一个拷贝。如果局部变量的值无法在编译期间确定，则通过构造器传参的方式来对拷贝进行初始化赋值。</code></p><p>　　从上面可以看出，在run方法中访问的变量a根本就不是test方法中的局部变量a。这样一来就解决了前面所说的 生命周期不一致的问题。但是新的问题又来了，既然在run方法中访问的变量a和test方法中的变量a不是同一个变量，当在run方法中改变变量a的值的话，会出现什么情况？</p><p>　　<code>对，会造成数据不一致性，这样就达不到原本的意图和要求。</code>为了解决这个问题，java编译器就限定必须将变量a限制为final变量，不允许对变量a进行更改（对于引用类型的变量，是不允许指向新的对象），这样数据不一致性的问题就得以解决了。</p><p>　　到这里，想必大家应该清楚为何 方法中的局部变量和形参都必须用final进行限定了。</p><h2 id="2-3-静态内部类有特殊的地方吗？"><a href="#2-3-静态内部类有特殊的地方吗？" class="headerlink" title="2.3 静态内部类有特殊的地方吗？"></a>2.3 静态内部类有特殊的地方吗？</h2><p>　　从前面可以知道，静态内部类是不依赖于外部类的，也就说可以在不创建外部类对象的情况下创建内部类的对象。另外，静态内部类是不持有指向外部类对象的引用的，这个读者可以自己尝试反编译class文件看一下就知道了，是没有Outter this&amp;0引用的。</p><h1 id="3-内部类的使用场景和好处"><a href="#3-内部类的使用场景和好处" class="headerlink" title="3.内部类的使用场景和好处"></a>3.内部类的使用场景和好处</h1><p>为什么在Java中需要内部类？总结一下主要有以下四点：</p><p>　　1.每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。内部类使得多继承的解决方案变得完整，</p><p>　　2.方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏。</p><p>　　3.方便编写事件驱动程序</p><p>　　4.方便编写线程代码</p><p>　　个人觉得第一点是最重要的原因之一，内部类的存在使得Java的多继承机制变得更加完善。</p><h1 id="4-常见的与内部类相关的笔试面试题"><a href="#4-常见的与内部类相关的笔试面试题" class="headerlink" title="4.常见的与内部类相关的笔试面试题"></a>4.常见的与内部类相关的笔试面试题</h1><p><strong>1.根据注释填写(1)，(2)，(3)处的代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">           <span class="comment">// 初始化Bean1</span></span><br><span class="line">           (<span class="number">1</span>)</span><br><span class="line">           bean1.I++;</span><br><span class="line">           <span class="comment">// 初始化Bean2</span></span><br><span class="line">           (<span class="number">2</span>)</span><br><span class="line">           bean2.J++;</span><br><span class="line">           <span class="comment">//初始化Bean3</span></span><br><span class="line">           (<span class="number">3</span>)</span><br><span class="line">           bean3.k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Bean1</span></span>&#123;</span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">int</span> I = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean2</span></span>&#123;</span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">int</span> J = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bean</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Bean3</span></span>&#123;</span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从前面可知，对于成员内部类，必须先产生外部类的实例化对象，才能产生内部类的实例化对象。而静态内部类不用产生外部类的实例化对象即可产生内部类的实例化对象。</p><p><code>创建静态内部类对象的一般形式为：  外部类类名.内部类类名 xxx = new 外部类类名.内部类类名()</code></p><p>　<code>创建成员内部类对象的一般形式为：  外部类类名.内部类类名 xxx = 外部类对象名.new 内部类类名()</code><br>　<br>因此，（1），（2），（3）处的代码分别为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//(1)</span></span><br><span class="line">Test test = <span class="keyword">new</span> Test();    </span><br><span class="line">Test.Bean1 bean1 = test.<span class="keyword">new</span> Bean1();  </span><br><span class="line"><span class="comment">//(2)</span></span><br><span class="line">Test.Bean2 b2 = <span class="keyword">new</span> Test.Bean2();   </span><br><span class="line"><span class="comment">//(3)</span></span><br><span class="line">Bean bean = <span class="keyword">new</span> Bean();     </span><br><span class="line">Bean.Bean3 bean3 =  bean.<span class="keyword">new</span> Bean3();</span><br></pre></td></tr></table></figure><p><strong>2.下面这段代码的输出结果是什么？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        Outter outter = <span class="keyword">new</span> Outter();</span><br><span class="line">        outter.<span class="keyword">new</span> Inner().print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">            System.out.println(<span class="string">"局部变量："</span> + a);</span><br><span class="line">            System.out.println(<span class="string">"内部类变量："</span> + <span class="keyword">this</span>.a);</span><br><span class="line">            System.out.println(<span class="string">"外部类变量："</span> + Outter.<span class="keyword">this</span>.a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>最后补充一点知识：关于成员内部类的继承问题。一般来说，内部类是很少用来作为继承用的。但是当用来继承的话，要注意两点：</strong></p><p>1）成员内部类的引用方式必须为 Outter.Inner.<br>2）构造器中必须有指向外部类对象的引用，并通过这个引用调用super()。这段代码摘自《Java编程思想》</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithInner</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InheritInner</span> <span class="keyword">extends</span> <span class="title">WithInner</span>.<span class="title">Inner</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// InheritInner() 是不能通过编译的，一定要加上形参</span></span><br><span class="line">    InheritInner(WithInner wi) &#123;</span><br><span class="line">        wi.<span class="keyword">super</span>(); <span class="comment">//必须有这句调用</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WithInner wi = <span class="keyword">new</span> WithInner();</span><br><span class="line">        InheritInner obj = <span class="keyword">new</span> InheritInner(wi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 参考资料：</p><p>　　《java编程思想》</p><p>　　<a href="http://www.cnblogs.com/chenssy/p/3388487.html" target="_blank" rel="noopener">http://www.cnblogs.com/chenssy/p/3388487.html</a></p><p>　　<a href="http://blog.csdn.net/zhangjg_blog/article/details/20000769" target="_blank" rel="noopener">http://blog.csdn.net/zhangjg_blog/article/details/20000769</a></p><p>　　<a href="http://blog.csdn.net/zhangjg_blog/article/details/19996629" target="_blank" rel="noopener">http://blog.csdn.net/zhangjg_blog/article/details/19996629</a></p><p>　　<a href="http://blog.csdn.net/zhaoqianjava/article/details/6849812" target="_blank" rel="noopener">http://blog.csdn.net/zhaoqianjava/article/details/6849812</a></p><p>　　<a href="http://www.cnblogs.com/nerxious/archive/2013/01/24/2875649.html" target="_blank" rel="noopener">http://www.cnblogs.com/nerxious/archive/2013/01/24/2875649.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> 内部类 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
