<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>肝了十几个小时的java反射，希望对大家有所帮助吧！</title>
      <link href="/posts/6e3bcb10.html"/>
      <url>/posts/6e3bcb10.html</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>Java的反射机制是Java特性之一，反射机制是构建框架技术的基础所在。灵活掌握Java反射机制，对以后学习框架技术有很大的帮助。</li><li>本篇文章用到的代码在我的github上面：<a href="https://github.com/BitHachi/Java_core_book/tree/master/src/JavaSE/Chapter5/Section57" target="_blank" rel="noopener">BitHachi/JJava_core_book/tree/master/src/JavaSE/Chapter5/Section57</a>。<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200722195924629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul></blockquote><h1 id="1-什么是Java的反射呢？"><a href="#1-什么是Java的反射呢？" class="headerlink" title="1.什么是Java的反射呢？"></a>1.什么是Java的反射呢？</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大家都知道，要让Java程序能够运行，那么就得让Java类要被Java虚拟机加载。Java类如果不被Java虚拟机加载，是不能正常运行的。现在我们运行的所有的程序都是在编译期的时候就已经知道了你所需要的那个类的已经被加载了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java的反射机制是在编译并不确定是哪个类被加载了，而是在程序运行的时候才加载、探知、自审。使用在编译期并不知道的类。这样的特点就是反射。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。</p><h1 id="2-Java反射有什么作用呢？"><a href="#2-Java反射有什么作用呢？" class="headerlink" title="2.Java反射有什么作用呢？"></a>2.Java反射有什么作用呢？</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假如我们有两个程序员，一个程序员在写程序的时候，需要使用第二个程序员所写的类，但第二个程序员并没完成他所写的类。那么第一个程序员的代码能否通过编译呢？这是不能通过编译的。利用Java反射的机制，就可以让第一个程序员在没有得到第二个程序员所写的类的时候，来完成自身代码的编译。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Java的反射机制它知道类的基本结构，这种对Java类结构探知的能力，我们称为Java类的“自审”。</code>大家都用过IDEA和eclipse。当我们构建出一个对象的时候，去调用该对象的方法和属性的时候。一按点，编译工具就会自动的把该对象能够使用的所有的方法和属性全部都列出来，供用户进行选择。这就是利用了Java反射的原理，是对我们创建对象的探知、自审。(反射是一种功能强大且复杂的机制。使用它的主要人员是工具构造者，而不是应用程序员。)</p><h1 id="3-Class类"><a href="#3-Class类" class="headerlink" title="3.Class类"></a>3.Class类</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要正确使用Java反射机制就得使用java.lang.Class这个类。它是Java反射机制的起源。当一个类被加载以后，Java虚拟机就会自动产生一个Class对象。通过这个Class对象我们就能获得加载到虚拟机当中这个Class对象对应的方法、成员变量以及构造方法的声明和定义等信息。</p><h1 id="4-获取class类对象"><a href="#4-获取class类对象" class="headerlink" title="4.获取class类对象"></a>4.获取class类对象</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;既然class对象如此重要，那么我们如何获取class对象呢？这里有三种方法： </p><h2 id="4-1-使用类对象的getClass-方法"><a href="#4-1-使用类对象的getClass-方法" class="headerlink" title="4.1  使用类对象的getClass()方法"></a>4.1  使用类对象的getClass()方法</h2><ul><li><p>使用类对象的getClass()方法<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200721223506271.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="4-2-Class-forName-classname"><a href="#4-2-Class-forName-classname" class="headerlink" title="4.2 Class.forName(classname)"></a>4.2 Class.forName(classname)</h2></li><li><p>使用 Class.forName(classname) 静态方法。当你知道该类的全路径名时，你可以使用该方法获取 Class 类对象</p></li><li><p>如果className不是类名或接口名，则forname抛出一个checked exception异常所以应该给这个方法提供一个异常处理器</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200721224056665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="4-3-class-方法"><a href="#4-3-class-方法" class="headerlink" title="4.3 .class 方法"></a>4.3 .class 方法</h2></li></ul><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200721224339711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="5-通过反射创建类对象"><a href="#5-通过反射创建类对象" class="headerlink" title="5.通过反射创建类对象"></a>5.通过反射创建类对象</h1><ul><li>既然通过上文我们知道了如何获取class对象，那么我们是不是就可以根据这个类对象来创建实例对象呢？当然可以</li><li>通过反射创建类对象主要有两种方式：通过 Class 对象的 newInstance() 方法、通过 Constructor 对象的 newInstance() 方法。<h2 id="5-1-Class-对象的-newInstance-方法"><a href="#5-1-Class-对象的-newInstance-方法" class="headerlink" title="5.1 Class 对象的 newInstance() 方法"></a>5.1 Class 对象的 newInstance() 方法</h2></li><li>newlnstance方法调用默认的构造器（没有参数的构造器）初始化新创建的对象。如果这个类没有默认的构造器， 就会抛出一个异常。<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200721230954365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h2 id="5-2-Constructor-对象的-newInstance-方法"><a href="#5-2-Constructor-对象的-newInstance-方法" class="headerlink" title="5.2  Constructor 对象的 newInstance() 方法"></a>5.2  Constructor 对象的 newInstance() 方法</h2><ul><li>通过 Constructor 对象创建类对象可以选择特定构造方法，而通过 Class 对象则只能使用默认的无参数构造方法。</li><li>这里getConstructor和newInstance使用时需要设置异常处理，我这里是直接在main后面throws了<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200721231841616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h1 id="6-获取类属性、方法、构造器的结构"><a href="#6-获取类属性、方法、构造器的结构" class="headerlink" title="6.获取类属性、方法、构造器的结构"></a>6.获取类属性、方法、构造器的结构</h1><ul><li>我们已经成功获取了class类对象，并学会了如何创建对象，现在我们还可以看看对象内部的结构是什么样的，比如属性、方法和构造器。</li><li>在java.lang.reflect 包中有三个类 Field、Method 和 Constructor分别用于描述类的属性、 方法和构造器<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br></pre></td></tr></table></figure></li></ul><p><strong>下面介绍一下 Field、Method 和 Constructor三个类的常用方法</strong></p><ul><li>Field类的getType 方法， 用来返回属性所属类型的 Class 对象</li><li>Method 类有一个getReturnType方法，返回return值所属类型的Class对象</li><li>Method 和 Constructor 类有一个共同的方法getParameterTypes，返回方法参数所属类型的Class对象</li><li>Field、Method 和 Constructor都有一个getName 方法，返回方法名的字符串</li><li>Field、Method 和 Constructor都有一个getModifiers方法，它将返回一个整型数值，用不同的位开关描述 public 和 static 这样 的修饰符使用状况。可以利用 Modifier.toString方法将 修饰符打印出来。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Method m : methods) &#123;</span><br><span class="line">String modifiers = Modifier.toString(m.getModifiers());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>该修饰符是java.lang.reflect.Modifier的静态属性。这里是用十进制表示的，源码里面是十六进制表示的。<br>对应表如下：<br>PUBLIC: 1<br>PRIVATE: 2<br>PROTECTED: 4<br>STATIC: 8<br>FINAL: 16<br>SYNCHRONIZED: 32<br>VOLATILE: 64<br>TRANSIENT: 128<br>NATIVE: 256<br>INTERFACE: 512<br>ABSTRACT: 1024<br>STRICT: 2048</p></blockquote><ul><li>可以使用Modifiei类中的 isPublic、 isPrivate 或 isFinal 判断方法或构造器是否是 public、 private 或 final</li><li>Class类中的 getFields、 getMethods 和 getConstructors方 法将 分 别 返 回 类 提 供 的 所有public 属性、 方法和构造器数组， 其中<code>包括超类的公有成员</code>。</li><li>Class 类的 getDeclareFields、 getDeclareMethods 和getDeclaredConstructors方法将分别返回类中声明的全部属性、 方法和构 造器， 其中包括private和protected成员，但<code>不包括超类的成员</code>。</li></ul><p><strong>下面是一个代码案例,显示了如何打印一个类的全部信息的方法。<br>这个程序提醒用户输入一个类名，然后输出类中所有的属性、方法、构造器。里面有一些数字是我用来测试，类似-m8-</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JavaSE.Chapter5.Section57.cs573;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This program uses reflection to print all features of a class.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Cay Horstmann</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.1 2004-02-21</span></span><br><span class="line"><span class="comment"> * 利用反射分析类的能力，查看属性、构造器、方法的结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           String name = <span class="string">"JavaSE.Chapter5.Section57.cs571.Employee"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取输入字符串的类对象</span></span><br><span class="line">            Class cl = Class.forName(name);</span><br><span class="line">            System.out.println(cl + <span class="string">"-1-"</span>);</span><br><span class="line">            <span class="comment">//获取父类对象</span></span><br><span class="line">            Class supercl = cl.getSuperclass();</span><br><span class="line">            System.out.println(supercl + <span class="string">"-2-"</span>);</span><br><span class="line">            <span class="comment">//获取类的访问修饰符和属于public、private、还是final</span></span><br><span class="line">            String modifiers = Modifier.toString(cl.getModifiers());</span><br><span class="line">            System.out.println(cl.getModifiers() + <span class="string">"-----cl.getModifiers"</span>);</span><br><span class="line">            System.out.println(modifiers + <span class="string">"-4-"</span>);</span><br><span class="line">            <span class="keyword">if</span> (modifiers.length() &gt; <span class="number">0</span>) System.out.print(modifiers + <span class="string">" "</span>);</span><br><span class="line">            System.out.print(<span class="string">"class "</span> + name);</span><br><span class="line">            if (supercl != null &amp;&amp; supercl != Object.class) System.out.print(" extends "</span><br><span class="line">                    + supercl.getName());</span><br><span class="line"></span><br><span class="line">            System.out.print(<span class="string">"\n&#123;\n"</span>);</span><br><span class="line">            System.out.println(<span class="string">"------------打印构造器方法-----------"</span>);</span><br><span class="line">            printConstructors(cl);</span><br><span class="line">            System.out.println(<span class="string">"------------打印非构造器方法-----------"</span>);</span><br><span class="line">            printMethods(cl);</span><br><span class="line">            System.out.println(<span class="string">"------------打印属性信息-----------"</span>);</span><br><span class="line">            printFields(cl);</span><br><span class="line">            System.out.println(<span class="string">"&#125;"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Prints all constructors of a class</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cl a class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printConstructors</span><span class="params">(Class cl)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*返回反映Constructor对象表示的类声明的所有Constructor对象的数组类 。</span></span><br><span class="line"><span class="comment">         这些是public，protected，default（package）访问和私有构造函数。</span></span><br><span class="line"><span class="comment">         返回的数组中的元素不会排序，并且不是任何特定的顺序。</span></span><br><span class="line"><span class="comment">         如果类有一个默认构造函数，它将包含在返回的数组中。</span></span><br><span class="line"><span class="comment">         如果类对象表示接口，原始类型，数组类或空值，则此方法返回长度为0的数组。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Constructor[] constructors = cl.getDeclaredConstructors();</span><br><span class="line">        System.out.println(Arrays.toString(constructors) + <span class="string">"-c5-"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Constructor c : constructors) &#123;</span><br><span class="line">            String name = c.getName();</span><br><span class="line">            System.out.print(<span class="string">"   "</span>);</span><br><span class="line">            String modifiers = Modifier.toString(c.getModifiers());</span><br><span class="line">            System.out.println(c.getModifiers() + <span class="string">"-----Counstructor.getModifiers"</span>);</span><br><span class="line">            <span class="comment">//打印构造方法的访问修饰符</span></span><br><span class="line">            <span class="keyword">if</span> (modifiers.length() &gt; <span class="number">0</span>) System.out.print(modifiers + <span class="string">" "</span>);</span><br><span class="line">            <span class="comment">//打印构造方法的名字</span></span><br><span class="line">            System.out.print(name + <span class="string">"("</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取类构造器的参数类型数组</span></span><br><span class="line">            Class[] paramTypes = c.getParameterTypes();</span><br><span class="line">            System.out.println(<span class="string">"-6-"</span> + Arrays.toString(paramTypes) + <span class="string">"-c6-"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; paramTypes.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) System.out.print(<span class="string">", "</span>);</span><br><span class="line">                <span class="comment">//打印参数类型名字</span></span><br><span class="line">                System.out.print(paramTypes[j].getName());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">");"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Prints all methods of a class</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cl a class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMethods</span><span class="params">(Class cl)</span> </span>&#123;</span><br><span class="line">        Method[] methods = cl.getDeclaredMethods();</span><br><span class="line">        System.out.println(Arrays.toString(methods) + <span class="string">"-m7-"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Method m : methods) &#123;</span><br><span class="line">            Class retType = m.getReturnType();</span><br><span class="line">            System.out.println(retType + <span class="string">"-m8-"</span>);</span><br><span class="line">            String name = m.getName();</span><br><span class="line"></span><br><span class="line">            System.out.print(<span class="string">"   "</span>);</span><br><span class="line">            <span class="comment">// print modifiers, return type and method name</span></span><br><span class="line">            String modifiers = Modifier.toString(m.getModifiers());</span><br><span class="line">            System.out.println(m.getModifiers() + <span class="string">"-----Method.getModifiers"</span>);</span><br><span class="line">            <span class="comment">//打印方法的访问修饰符</span></span><br><span class="line">            <span class="keyword">if</span> (modifiers.length() &gt; <span class="number">0</span>) System.out.print(modifiers + <span class="string">" "</span>);</span><br><span class="line">            <span class="comment">//打印方法返回类型和方法名</span></span><br><span class="line">            System.out.print(retType.getName() + <span class="string">" "</span> + name + <span class="string">"("</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// print parameter types</span></span><br><span class="line">            Class[] paramTypes = m.getParameterTypes();</span><br><span class="line">            System.out.println(<span class="string">"-m9-"</span> + Arrays.toString(paramTypes) + <span class="string">"-m9-"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; paramTypes.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) System.out.print(<span class="string">", "</span>);</span><br><span class="line">                <span class="comment">//打印方法参数类型</span></span><br><span class="line">                System.out.print(paramTypes[j].getName());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">");"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Prints all fields of a class</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cl a class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFields</span><span class="params">(Class cl)</span> </span>&#123;</span><br><span class="line">        Field[] fields = cl.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f : fields) &#123;</span><br><span class="line">            Class type = f.getType();<span class="comment">//返回属性所属类型的 Class 对象</span></span><br><span class="line">            System.out.println(type + <span class="string">"-f10-"</span>);</span><br><span class="line">            String name = f.getName();</span><br><span class="line">            System.out.print(<span class="string">"   "</span>);</span><br><span class="line">            String modifiers = Modifier.toString(f.getModifiers());</span><br><span class="line">            System.out.println(f.getModifiers() + <span class="string">"-----Field.getModifiers"</span>);</span><br><span class="line">            <span class="comment">//打印属性的访问修饰符</span></span><br><span class="line">            <span class="keyword">if</span> (modifiers.length() &gt; <span class="number">0</span>) System.out.print(modifiers + <span class="string">" "</span>);</span><br><span class="line">            <span class="comment">//打印属性的类型名和属性名字</span></span><br><span class="line">            System.out.println(type.getName() + <span class="string">" "</span> + name + <span class="string">";"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200722195702267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200722195718811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200722195729203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="7-获取或设置类对象的属性值"><a href="#7-获取或设置类对象的属性值" class="headerlink" title="7.获取或设置类对象的属性值"></a>7.获取或设置类对象的属性值</h1><ul><li>在编写程序时， 如果知道想要査看的属性和类型，查看指定的属性值是一件很容易的事情。而利用反射机制可以查看在编译时还不清楚的属性值。</li><li><code>Class t = f.getType();</code>//获取属性类型,f为Field对象。</li><li>我们可以用<code>f.get(obj)</code>获取 obj 属性的当前值。f为Field对象，obj是一个Object对象。</li><li>可以获得就可以设置。调用<code>f.set(obj，value)</code>可以将 obj 对象的 f 属性设置成新值。f为Field对象。<ul><li>（1）如果我们要查看某个private属性的值，由于受限于java的访问机制，我们需要调用Field、Method 或 Constructor 对象的 setAccessible 方法，来设置private的值的可访问性，<code>x. setAccessible(true);</code>，x为Field、Method 或 Constructor的对象。<br>（2）也可以使用<code>AccessibleObject.setAccessible(x, true);</code>来设置private值的可访问性，它是 Field、 Method 和 Constructor 类的公共超类，x为Field、Method 或 Constructor 对象的数组引用。</li></ul></li></ul><p><strong>接下来的一个例子将使用上面所说的方法，来查看访问对象的属性值</strong></p><p>如下一个可供任意类使用的通用 toString方法。 其中使用 getDeclaredFileds 获得所有的数据属性， 然后使用 setAccessible 将所有的属性设置为可访问的。 对于每个属性，获得了名字和值。递归调用 toString方法，将每个值转换成字符串。(这个例子是java核心技术卷一里面的，这个例子看懂我感觉还是需要花时间的，有的地方我还没看懂……)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JavaSE.Chapter5.Section57.cs574;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> JavaSE.Chapter5.Section57.cs571.Employee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在运行时使用反射分析对象，查看对象当前的各个属性值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectAnalyzerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, NoSuchFieldException, InstantiationException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Employee s = <span class="keyword">new</span> Employee();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> ObjectAnalyzer().toString(s));</span><br><span class="line">        System.out.println(<span class="string">"--------------------------------"</span>);</span><br><span class="line">        String[] str = &#123;<span class="string">"str11"</span>, <span class="string">"str22"</span>, <span class="string">"str33"</span>&#125;;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> ObjectAnalyzer().toString(str));</span><br><span class="line">        System.out.println(<span class="string">"--------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        Class em = s.getClass();</span><br><span class="line">        Object obj = em.newInstance();</span><br><span class="line">        Field f = em.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object val = f.get(obj);<span class="comment">//获取属性的值</span></span><br><span class="line">        System.out.println(val);</span><br><span class="line">        f.set(obj, <span class="string">"BitHachi"</span>);</span><br><span class="line">        Employee em2 = (Employee) obj;</span><br><span class="line">        System.out.println(em2.getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JavaSE.Chapter5.Section57.cs574;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.AccessibleObject;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectAnalyzer</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> ArrayList&lt;Object&gt; visited = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (obj == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">"null"</span>;</span><br><span class="line">      <span class="keyword">if</span> (visited.contains(obj)) <span class="keyword">return</span> <span class="string">"..."</span>;</span><br><span class="line">      visited.add(obj);</span><br><span class="line">      Class cl = obj.getClass();</span><br><span class="line">      <span class="comment">//如果对象是一个字符串对象，则直接打印其值</span></span><br><span class="line">      <span class="keyword">if</span> (cl == String<span class="class">.<span class="keyword">class</span>) <span class="title">return</span> (<span class="title">String</span>) <span class="title">obj</span></span>;</span><br><span class="line">      <span class="comment">//判断类对象是否是一个数组</span></span><br><span class="line">      <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">         <span class="comment">//getComponentType返回对象数组的的Class类对象。 如果此类不表示数组类，则此方法返回null。</span></span><br><span class="line">         String r = cl.getComponentType() + <span class="string">"[]&#123;"</span>;</span><br><span class="line">         System.out.println(r + <span class="string">"-1-"</span>);</span><br><span class="line">         <span class="comment">//返回指定数组对象的长度Array.getLength(obj)</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Array.getLength(obj); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) r += <span class="string">","</span>;</span><br><span class="line">            <span class="comment">//返回指定数组对象中的索引组件的值。</span></span><br><span class="line">            Object val = Array.get(obj, i);</span><br><span class="line">            System.out.println(val + <span class="string">" -val -2-"</span>);</span><br><span class="line">            <span class="comment">/*确定指定类对象表示一个基本类型。</span></span><br><span class="line"><span class="comment">            有九个预定类对象代表八个原始类型和void。</span></span><br><span class="line"><span class="comment">            这些是由Java虚拟机创建，并且具有相同的名称为他们所代表的基本类型，</span></span><br><span class="line"><span class="comment">            即boolean ， byte ， char ， short ， int ， long ， float和double 。</span></span><br><span class="line"><span class="comment">            isPrimitive返回一个boolean值*/</span></span><br><span class="line">            <span class="keyword">if</span> (cl.getComponentType().isPrimitive()) r += <span class="string">"@"</span> + val + <span class="string">"@"</span>;</span><br><span class="line">            <span class="keyword">else</span> r += toString(val);</span><br><span class="line">            System.out.println(r + <span class="string">"-3-"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> r + <span class="string">"&#125;"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      String r = cl.getName();</span><br><span class="line">      System.out.println(r + <span class="string">"-4-"</span>);</span><br><span class="line">      <span class="comment">// 检查此类和所有超类的字段</span></span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">         r += <span class="string">"["</span>;</span><br><span class="line">         <span class="comment">//获取类的所有属性得一个数组</span></span><br><span class="line">         Field[] fields = cl.getDeclaredFields();</span><br><span class="line">         <span class="comment">/*setAccessible()为反射对象设置可访问标志。 true 表明屏蔽 Java语言的访问检查，</span></span><br><span class="line"><span class="comment">         使得对象的 private私有属性也可以被査询和设置。 */</span></span><br><span class="line">         AccessibleObject.setAccessible(fields, <span class="keyword">true</span>);</span><br><span class="line">         <span class="comment">//获取所有属性的名字和值</span></span><br><span class="line">         <span class="keyword">for</span> (Field f : fields) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isStatic(f.getModifiers())) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!r.endsWith(<span class="string">"["</span>)) r += <span class="string">","</span>;</span><br><span class="line">               r += f.getName() + <span class="string">"="</span>;</span><br><span class="line">               System.out.println(r + <span class="string">"-5-"</span>);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                  Class t = f.getType();<span class="comment">//获取属性类型</span></span><br><span class="line">                  Object val = f.get(obj);<span class="comment">//获取属性的值</span></span><br><span class="line">                  System.out.println(val + <span class="string">" -val -6-"</span>);</span><br><span class="line">                  <span class="keyword">if</span> (t.isPrimitive()) &#123;</span><br><span class="line">                     r += val;</span><br><span class="line">                     System.out.println(r + <span class="string">"-7-"</span>);</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     r += toString(val);</span><br><span class="line">                     System.out.println(r + <span class="string">"-7-"</span>);</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">               &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         r += <span class="string">"]"</span>;</span><br><span class="line">         cl = cl.getSuperclass();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (cl != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> r;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200722195249588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="8-利用反射调用任意方法"><a href="#8-利用反射调用任意方法" class="headerlink" title="8.利用反射调用任意方法"></a>8.利用反射调用任意方法</h1><ul><li>反射机制可以允许调用任意的方法</li><li>在Method类中有一个invoke方法，它可以允许调用包装在Method对象中的方法</li></ul><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200722202224750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200722202235180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>下面是一个代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JavaSE.Chapter5.Section57.cs576;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodTableTest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">// 获取相应方法的Method对象，通过类对象来获取方法对象</span></span><br><span class="line">      Method square = MethodTableTest.class.getMethod("square", double.class);</span><br><span class="line">      Method sqrt = Math.class.getMethod("sqrt", double.class);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 打印x和y值表</span></span><br><span class="line">      printTable(<span class="number">1</span>, <span class="number">10</span>, <span class="number">10</span>, square);</span><br><span class="line">      printTable(<span class="number">1</span>, <span class="number">10</span>, <span class="number">10</span>, sqrt);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> x * x;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Prints a table with x- and y-values for a method</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> from the lower bound for the x-values 上限</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> to   the upper bound for the x-values  下限</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> n    the number of rows in the table   个数</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> f    a method with a double parameter and double return value</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTable</span><span class="params">(<span class="keyword">double</span> from, <span class="keyword">double</span> to, <span class="keyword">int</span> n, Method f)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// print out the method as table header</span></span><br><span class="line">      System.out.println(<span class="string">"方法： "</span> + f);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">double</span> dx = (to - from) / (n - <span class="number">1</span>);<span class="comment">//按上下限设置每次加的值</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">double</span> x = from; x &lt;= to; x += dx) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> y = (Double) f.invoke(<span class="keyword">null</span>, x);<span class="comment">//调用这个方法对象进行计算</span></span><br><span class="line">            System.out.printf(<span class="string">"%10.4f | %10.4f%n"</span>, x, y);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/2020072220232476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="9-使用反射编写泛型数组代码，复制数组"><a href="#9-使用反射编写泛型数组代码，复制数组" class="headerlink" title="9. 使用反射编写泛型数组代码，复制数组"></a>9. 使用反射编写泛型数组代码，复制数组</h1><ul><li>我们可以利用反射来扩充一个数组的容量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JavaSE.Chapter5.Section57.cs575;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOfTest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">      a = (<span class="keyword">int</span>[]) goodCopyOf(a, <span class="number">10</span>);</span><br><span class="line">      System.out.println(Arrays.toString(a));</span><br><span class="line">      System.out.println(<span class="string">"--------------------"</span>);</span><br><span class="line">      String[] b = &#123;<span class="string">"Tom"</span>, <span class="string">"Dick"</span>, <span class="string">"Harry"</span>&#125;;</span><br><span class="line">      b = (String[]) goodCopyOf(b, <span class="number">10</span>);</span><br><span class="line">      System.out.println(Arrays.toString(b));</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">goodCopyOf</span><span class="params">(Object a, <span class="keyword">int</span> newLength)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//第一步：获取a数组的类对象</span></span><br><span class="line">      Class cl = a.getClass();</span><br><span class="line">      System.out.println(cl + <span class="string">"---1"</span>);</span><br><span class="line">      <span class="comment">//第二步：判断a数组的类对象是否是一个数组</span></span><br><span class="line">      <span class="keyword">if</span> (!cl.isArray()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//第三步：使用Class类的getComponentType方法确定数组对应的类型</span></span><br><span class="line">      Class componentType = cl.getComponentType();</span><br><span class="line">      System.out.println(componentType + <span class="string">"---2"</span>);</span><br><span class="line">      <span class="comment">//获取数组的长度</span></span><br><span class="line">      <span class="keyword">int</span> length = Array.getLength(a);</span><br><span class="line">      System.out.println(length + <span class="string">"---3"</span>);</span><br><span class="line">      <span class="comment">//构造新数组newInstance方法</span></span><br><span class="line">      <span class="comment">//返回一个具有给定类型、给定长度的新数组</span></span><br><span class="line">      Object newArray = Array.newInstance(componentType, newLength);</span><br><span class="line">      <span class="comment">/*arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</span></span><br><span class="line"><span class="comment">      将指定源数组中的数组从指定位置复制到目标数组的指定位置。*/</span></span><br><span class="line">      System.arraycopy(a, <span class="number">0</span>, newArray, <span class="number">0</span>, Math.min(length, newLength));</span><br><span class="line">      <span class="keyword">return</span> newArray;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/2020072220285340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="10-可以用-比较两个Class对象"><a href="#10-可以用-比较两个Class对象" class="headerlink" title="10. 可以用==比较两个Class对象"></a>10. 可以用==比较两个Class对象</h1><ul><li>虚拟机为每个类型管理一个 Class 对象。因此， 可以利用== 运算符实现两个类对象比较的操作。 例如:</li></ul><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200617213040641.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="11-收获与感受"><a href="#11-收获与感受" class="headerlink" title="11.收获与感受"></a>11.收获与感受</h1><ul><li>反射里面用到了多态的特性，这一点真的很重要，特别是Object与其它对象之间的互转，不懂得话，很容易懵圈</li><li>4-8的应用是反射里面的核心点，当然还有很多的API没办法一次性讲完，其实只要懂了核心的部分，其它的API就比较好懂了</li><li>关于反射的内容和应用还有很多，以后在工作中遇到了相关内容再进行补充叭，现在作为初学者，先总结整理这么多叭。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html#%E5%8F%8D%E5%B0%84%E5%B8%B8%E7%94%A8api" target="_blank" rel="noopener">https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html#%E5%8F%8D%E5%B0%84%E5%B8%B8%E7%94%A8api</a></li><li><a href="https://www.iteye.com/blog/762626559-qq-com-395402" target="_blank" rel="noopener">https://www.iteye.com/blog/762626559-qq-com-395402</a></li><li><a href="https://blog.csdn.net/qq_40434646/article/details/82351488" target="_blank" rel="noopener">https://blog.csdn.net/qq_40434646/article/details/82351488</a></li><li><a href="https://blog.csdn.net/kjfcpua/article/details/8496911" target="_blank" rel="noopener">https://blog.csdn.net/kjfcpua/article/details/8496911</a></li><li><a href="http://yuncode.net/code/c_56768be18995515" target="_blank" rel="noopener">http://yuncode.net/code/c_56768be18995515</a></li><li><a href="https://www.cnblogs.com/fengmao/p/8609855.html" target="_blank" rel="noopener">https://www.cnblogs.com/fengmao/p/8609855.html</a></li><li><a href="https://www.cnblogs.com/daimajun/p/6545533.html" target="_blank" rel="noopener">https://www.cnblogs.com/daimajun/p/6545533.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《MySQL必知必会》所有SQL语句图表集合（可作为查询表使用）---持续更新</title>
      <link href="/posts/dfcd7c37.html"/>
      <url>/posts/dfcd7c37.html</url>
      
        <content type="html"><![CDATA[<ul><li>本篇文章是对《MySQL必知必会》所有语句知识点的图表集合，适合快速查询遗忘的SQL语句，<code>原创不易，转载请注明出处</code>。</li><li>本文的脉络结构，首先先给出《MySQL必知必会》的目录，有一个全局的认识，方便查找，然后依次列出三张表。</li><li>SQL语句图表集合总共分为三张，<code>第一张</code>的内容是书中3-13章的内容，<code>第二张</code>是14-22章的内容，<code>第三张</code>是23-30章的内容，希望对大家学习MySQL的SQL语句有所帮助叭！</li></ul><h1 id="1-《MySQL必知必会》目录"><a href="#1-《MySQL必知必会》目录" class="headerlink" title="1.《MySQL必知必会》目录"></a>1.《MySQL必知必会》目录</h1><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200721140609365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200721140403664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200721140427144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200721140449494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200721140510256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="2-第一张"><a href="#2-第一张" class="headerlink" title="2.第一张"></a>2.第一张</h1><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200721141746353.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内部类详解(使用场景和好处、相关内部类的笔试面试题)</title>
      <link href="/posts/bf7b3e18.html"/>
      <url>/posts/bf7b3e18.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>此篇文章作者为：Matrix海子　　　　<br>出处：<a href="http://www.cnblogs.com/dolphin0520/" target="_blank" rel="noopener">http://www.cnblogs.com/dolphin0520/</a></p></blockquote><p>最近也是在学习java，看的是《java核心技术卷一》jdk8，看到内部类的知识点有一点模糊不清，偶然间看到作者写的这篇文章，把我在书中没有完全理解和疑惑的地方全讲清楚了，虽然关于字节码那部分对我这个初学者来说有一些参数看不懂，但是大致通过作者的叙述和自己的思考，可以理解大部分，相信对我以后学习jvm会很有帮助，能看到这篇文章，万分荣幸，感谢作者的心血付出，膜拜。</p><p><strong>进入正文：</strong><br>说起内部类这个词，想必很多人都不陌生，但是又会觉得不熟悉。原因是平时编写代码时可能用到的场景不多，用得最多的是在有事件监听的情况下，并且即使用到也很少去总结内部类的用法。今天我们就来一探究竟。</p><h1 id="1-内部类基础"><a href="#1-内部类基础" class="headerlink" title="1.内部类基础"></a>1.内部类基础</h1><p>在Java中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。广泛意义上的内部类一般来说包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类。下面就先来了解一下这四种内部类的用法。</p><h2 id="1-1-成员内部类"><a href="#1-1-成员内部类" class="headerlink" title="1.1 成员内部类"></a>1.1 成员内部类</h2><p>　　成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius = <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Draw</span> </span>&#123;     <span class="comment">//内部类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSahpe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"drawshape"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样看起来，类Draw像是类Circle的一个成员，Circle称为外部类。成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count =<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Draw</span> </span>&#123;     <span class="comment">//内部类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSahpe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(radius);  <span class="comment">//外部类的private成员</span></span><br><span class="line">            System.out.println(count);   <span class="comment">//外部类的静态成员</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">外部类.<span class="keyword">this</span>.成员变量</span><br><span class="line">外部类.<span class="keyword">this</span>.成员方法</span><br></pre></td></tr></table></figure><p>虽然成员内部类可以无条件地访问外部类的成员，而外部类想访问成员内部类的成员却不是这么随心所欲了。在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">        getDrawInstance().drawSahpe();   <span class="comment">//必须先创建成员内部类的对象，再进行访问</span></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Draw <span class="title">getDrawInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Draw();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Draw</span> </span>&#123;     <span class="comment">//内部类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSahpe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(radius);  <span class="comment">//外部类的private成员</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="comment">//第一种方式：</span></span><br><span class="line">        Outter outter = <span class="keyword">new</span> Outter();</span><br><span class="line">        Outter.Inner inner = outter.<span class="keyword">new</span> Inner();  <span class="comment">//必须通过Outter对象来创建</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//第二种方式：</span></span><br><span class="line">        Outter.Inner inner1 = outter.getInnerInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Inner inner = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner <span class="title">getInnerInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inner == <span class="keyword">null</span>)</span><br><span class="line">            inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        <span class="keyword">return</span> inner;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。比如上面的例子，如果成员内部类Inner用private修饰，则只能在外部类的内部访问，如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。这一点和外部类有一点不一样，外部类只能被public和包访问两种权限修饰。我个人是这么理解的，由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰。</p><blockquote><p>这里插入作者当时版本没有考虑到的一个问题：<br>“<code>局部内部类和匿名内部类</code>只能访问局部final变量”<br>从JDK 1.8开始，会默认给这两种内部类访问的field 加上final(隐式地)，所以你可能会在编译器中看到可以访问没有加final的变量，只有你去<code>修改</code>它时，编译器才会<code>报错</code>。</p></blockquote><h2 id="1-2-局部内部类"><a href="#1-2-局部内部类" class="headerlink" title="1.2 局部内部类"></a>1.2 局部内部类</h2><p>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Man</span><span class="params">()</span></span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> People <span class="title">getWoman</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123;   <span class="comment">//局部内部类</span></span><br><span class="line">            <span class="keyword">int</span> age =<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Woman();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。</p><h2 id="1-3-匿名内部类"><a href="#1-3-匿名内部类" class="headerlink" title="1.3 匿名内部类"></a>1.3 匿名内部类</h2><p>匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。下面这段代码是一段Android事件监听代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">scan_bt.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">             </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">                 </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">         </span><br><span class="line">        history_bt.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">             </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">                 </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>这段代码为两个按钮设置监听器，这里面就使用了匿名内部类。这段代码中的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">             </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">                 </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>就是匿名内部类的使用。代码中需要给按钮设置监听器对象，使用匿名内部类能够在实现父类或者接口中的方法情况下同时产生一个相应的对象，但是前提是这个父类或者接口必须先存在才能这样使用。当然像下面这种写法也是可以的，跟上面使用匿名内部类达到效果相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setListener</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    scan_bt.setOnClickListener(<span class="keyword">new</span> Listener1());       </span><br><span class="line">    history_bt.setOnClickListener(<span class="keyword">new</span> Listener2());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Listener1</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">             </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Listener2</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">             </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法虽然能达到一样的效果，但是既冗长又难以维护，所以一般使用匿名内部类的方法来编写事件监听代码。同样的，匿名内部类也是不能有访问修饰符和static修饰符的。</p><p>　　匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为Outter$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。</p><h2 id="1-4-静态内部类"><a href="#1-4-静态内部类" class="headerlink" title="1.4 静态内部类"></a>1.4 静态内部类</h2><p>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        Outter.Inner inner = <span class="keyword">new</span> Outter.Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200720231313280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="2-深入理解内部类"><a href="#2-深入理解内部类" class="headerlink" title="2.深入理解内部类"></a>2.深入理解内部类</h1><h2 id="2-1-为什么成员内部类可以无条件访问外部类的成员？"><a href="#2-1-为什么成员内部类可以无条件访问外部类的成员？" class="headerlink" title="2.1 为什么成员内部类可以无条件访问外部类的成员？"></a>2.1 为什么成员内部类可以无条件访问外部类的成员？</h2><p>　　在此之前，我们已经讨论过了成员内部类可以无条件访问外部类的成员，那具体究竟是如何实现的呢？下面通过反编译字节码文件看看究竟。事实上，编译器在进行编译的时候，会将成员内部类单独编译成一个字节码文件，下面是Outter.java的代码：　　</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Inner inner = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner <span class="title">getInnerInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inner == <span class="keyword">null</span>)</span><br><span class="line">            inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        <span class="keyword">return</span> inner;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译之后，出现了两个字节码文件：</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200720231435730.png" alt="在这里插入图片描述"></p><p>反编译Outter$Inner.class文件得到下面信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">E:\Workspace\Test\bin\com\cxh\test2&gt;javap -v Outter$Inner</span><br><span class="line">Compiled from <span class="string">"Outter.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">cxh</span>.<span class="title">test2</span>.<span class="title">Outter</span>$<span class="title">Inner</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span></span></span><br><span class="line">  SourceFile: "Outter.java"</span><br><span class="line">  InnerClass:</span><br><span class="line">   #24= #1 of #22; //Inner=class com/cxh/test2/Outter$Inner of class com/cxh/tes</span><br><span class="line">t2/Outter</span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">50</span></span><br><span class="line">  Constant pool:</span><br><span class="line">const #1 = class        #2;     //  com/cxh/test2/Outter$Inner</span><br><span class="line">const #2 = Asciz        com/cxh/test2/Outter$Inner;</span><br><span class="line">const #3 = class        #4;     //  java/lang/Object</span><br><span class="line">const #4 = Asciz        java/lang/Object;</span><br><span class="line">const #5 = Asciz        this$0;</span><br><span class="line">const #6 = Asciz        Lcom/cxh/test2/Outter;;</span><br><span class="line">const #7 = Asciz        &lt;init&gt;;</span><br><span class="line">const #8 = Asciz        (Lcom/cxh/test2/Outter;)V;</span><br><span class="line">const #9 = Asciz        Code;</span><br><span class="line">const #10 = Field       #1.#11; //  com/cxh/test2/Outter$Inner.this$0:Lcom/cxh/t</span><br><span class="line">est2/Outter;</span><br><span class="line">const #11 = NameAndType #5:#6;//  this$0:Lcom/cxh/test2/Outter;</span><br><span class="line">const #12 = Method      #3.#13; //  java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">const #13 = NameAndType #7:#14;//  "&lt;init&gt;":()V</span><br><span class="line">const #14 = Asciz       ()V;</span><br><span class="line">const #15 = Asciz       LineNumberTable;</span><br><span class="line">const #16 = Asciz       LocalVariableTable;</span><br><span class="line">const #17 = Asciz       this;</span><br><span class="line">const #18 = Asciz       Lcom/cxh/test2/Outter$Inner;;</span><br><span class="line">const #19 = Asciz       SourceFile;</span><br><span class="line">const #20 = Asciz       Outter.java;</span><br><span class="line">const #21 = Asciz       InnerClasses;</span><br><span class="line">const #22 = class       #23;    //  com/cxh/test2/Outter</span><br><span class="line">const #23 = Asciz       com/cxh/test2/Outter;</span><br><span class="line">const #24 = Asciz       Inner;</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">final</span> com.cxh.test2.Outter <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> com.cxh.test2.Outter$Inner(com.cxh.test2.Outter);</span><br><span class="line">  Code:</span><br><span class="line">   Stack=<span class="number">2</span>, Locals=<span class="number">2</span>, Args_size=<span class="number">2</span></span><br><span class="line">   <span class="number">0</span>:   aload_0</span><br><span class="line">   <span class="number">1</span>:   aload_1</span><br><span class="line">   2:   putfield        #10; //Field this$0:Lcom/cxh/test2/Outter;</span><br><span class="line">   <span class="number">5</span>:   aload_0</span><br><span class="line">   6:   invokespecial   #12; //Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   <span class="number">9</span>:   <span class="keyword">return</span></span><br><span class="line">  LineNumberTable:</span><br><span class="line">   line <span class="number">16</span>: <span class="number">0</span></span><br><span class="line">   line <span class="number">18</span>: <span class="number">9</span></span><br><span class="line"> </span><br><span class="line">  LocalVariableTable:</span><br><span class="line">   Start  Length  Slot  Name   Signature</span><br><span class="line">   <span class="number">0</span>      <span class="number">10</span>      <span class="number">0</span>    <span class="keyword">this</span>       Lcom/cxh/test2/Outter$Inner;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第11行到35行是常量池的内容，下面逐一第38行的内容：<br><code>final com.cxh.test2.Outter this$0;</code></p><p>　这行是一个指向外部类对象的指针，看到这里想必大家豁然开朗了。也就是说编译器会默认为成员内部类添加了一个指向外部类对象的引用，那么这个引用是如何赋初值的呢？下面接着看内部类的构造器：<br>　<br><code>public com.cxh.test2.Outter$Inner(com.cxh.test2.Outter);</code></p><p>从这里可以看出，虽然我们在定义的内部类的构造器是无参构造器，编译器还是会默认添加一个参数，该参数的类型为指向外部类对象的一个引用，所以成员内部类中的Outter this&amp;0 指针便指向了外部类对象，因此可以在成员内部类中随意访问外部类的成员。从这里也间接说明了成员内部类是依赖于外部类的，如果没有创建外部类的对象，则无法对Outter this&amp;0引用进行初始化赋值，也就无法创建成员内部类的对象了。</p><h2 id="2-2-为什么局部内部类和匿名内部类只能访问局部final变量？"><a href="#2-2-为什么局部内部类和匿名内部类只能访问局部final变量？" class="headerlink" title="2.2 为什么局部内部类和匿名内部类只能访问局部final变量？"></a>2.2 为什么局部内部类和匿名内部类只能访问局部final变量？</h2><p>想必这个问题也曾经困扰过很多人，在讨论这个问题之前，先看下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码会被编译成两个class文件：Test.class和Test1.class。默认情况下，编译器会为匿名内部类和局部内部类起名为Outterx.class（x为正整数）。</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200720231625870.png" alt="在这里插入图片描述"></p><p>根据上图可知，test方法中的匿名内部类的名字被起为 Test$1。</p><p>　　上段代码中，如果把变量a和b前面的任一个final去掉，这段代码都编译不过。我们先考虑这样一个问题：</p><p>　　当test方法执行完毕之后，变量a的生命周期就结束了，而此时Thread对象的生命周期很可能还没有结束，那么在Thread的run方法中继续访问变量a就变成不可能了，但是又要实现这样的效果，怎么办呢？Java采用了 <code>复制</code>  的手段来解决这个问题。将这段代码的字节码反编译可以得到下面的内容：</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/2020072023164318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>我们看到在run方法中有一条指令：</p><p><code>bipush 10</code></p><p>这条指令表示将操作数10压栈，表示使用的是一个本地局部变量。这个过程是在编译期间由编译器默认进行，如果这个变量的值在编译期间可以确定，则编译器默认会在匿名内部类（局部内部类）的常量池中添加一个内容相等的字面量或直接将相应的字节码嵌入到执行字节码中。这样一来，匿名内部类使用的变量是另一个局部变量，只不过值和方法中局部变量的值相等，因此和方法中的局部变量完全独立开。</p><p><strong>下面再看一个例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译得到：</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20200720231732185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们看到匿名内部类Test$1的构造器含有两个参数，一个是指向外部类对象的引用，一个是int型变量，很显然，这里是将变量test方法中的形参a以参数的形式传进来对匿名内部类中的拷贝（变量a的拷贝）进行赋值初始化。</p><p>　<code>也就说如果局部变量的值在编译期间就可以确定，则直接在匿名内部里面创建一个拷贝。如果局部变量的值无法在编译期间确定，则通过构造器传参的方式来对拷贝进行初始化赋值。</code></p><p>　　从上面可以看出，在run方法中访问的变量a根本就不是test方法中的局部变量a。这样一来就解决了前面所说的 生命周期不一致的问题。但是新的问题又来了，既然在run方法中访问的变量a和test方法中的变量a不是同一个变量，当在run方法中改变变量a的值的话，会出现什么情况？</p><p>　　<code>对，会造成数据不一致性，这样就达不到原本的意图和要求。</code>为了解决这个问题，java编译器就限定必须将变量a限制为final变量，不允许对变量a进行更改（对于引用类型的变量，是不允许指向新的对象），这样数据不一致性的问题就得以解决了。</p><p>　　到这里，想必大家应该清楚为何 方法中的局部变量和形参都必须用final进行限定了。</p><h2 id="2-3-静态内部类有特殊的地方吗？"><a href="#2-3-静态内部类有特殊的地方吗？" class="headerlink" title="2.3 静态内部类有特殊的地方吗？"></a>2.3 静态内部类有特殊的地方吗？</h2><p>　　从前面可以知道，静态内部类是不依赖于外部类的，也就说可以在不创建外部类对象的情况下创建内部类的对象。另外，静态内部类是不持有指向外部类对象的引用的，这个读者可以自己尝试反编译class文件看一下就知道了，是没有Outter this&amp;0引用的。</p><h1 id="3-内部类的使用场景和好处"><a href="#3-内部类的使用场景和好处" class="headerlink" title="3.内部类的使用场景和好处"></a>3.内部类的使用场景和好处</h1><p>为什么在Java中需要内部类？总结一下主要有以下四点：</p><p>　　1.每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。内部类使得多继承的解决方案变得完整，</p><p>　　2.方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏。</p><p>　　3.方便编写事件驱动程序</p><p>　　4.方便编写线程代码</p><p>　　个人觉得第一点是最重要的原因之一，内部类的存在使得Java的多继承机制变得更加完善。</p><h1 id="4-常见的与内部类相关的笔试面试题"><a href="#4-常见的与内部类相关的笔试面试题" class="headerlink" title="4.常见的与内部类相关的笔试面试题"></a>4.常见的与内部类相关的笔试面试题</h1><p><strong>1.根据注释填写(1)，(2)，(3)处的代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">           <span class="comment">// 初始化Bean1</span></span><br><span class="line">           (<span class="number">1</span>)</span><br><span class="line">           bean1.I++;</span><br><span class="line">           <span class="comment">// 初始化Bean2</span></span><br><span class="line">           (<span class="number">2</span>)</span><br><span class="line">           bean2.J++;</span><br><span class="line">           <span class="comment">//初始化Bean3</span></span><br><span class="line">           (<span class="number">3</span>)</span><br><span class="line">           bean3.k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Bean1</span></span>&#123;</span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">int</span> I = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean2</span></span>&#123;</span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">int</span> J = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bean</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Bean3</span></span>&#123;</span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从前面可知，对于成员内部类，必须先产生外部类的实例化对象，才能产生内部类的实例化对象。而静态内部类不用产生外部类的实例化对象即可产生内部类的实例化对象。</p><p><code>创建静态内部类对象的一般形式为：  外部类类名.内部类类名 xxx = new 外部类类名.内部类类名()</code></p><p>　<code>创建成员内部类对象的一般形式为：  外部类类名.内部类类名 xxx = 外部类对象名.new 内部类类名()</code><br>　<br>因此，（1），（2），（3）处的代码分别为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//(1)</span></span><br><span class="line">Test test = <span class="keyword">new</span> Test();    </span><br><span class="line">Test.Bean1 bean1 = test.<span class="keyword">new</span> Bean1();  </span><br><span class="line"><span class="comment">//(2)</span></span><br><span class="line">Test.Bean2 b2 = <span class="keyword">new</span> Test.Bean2();   </span><br><span class="line"><span class="comment">//(3)</span></span><br><span class="line">Bean bean = <span class="keyword">new</span> Bean();     </span><br><span class="line">Bean.Bean3 bean3 =  bean.<span class="keyword">new</span> Bean3();</span><br></pre></td></tr></table></figure><p><strong>2.下面这段代码的输出结果是什么？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        Outter outter = <span class="keyword">new</span> Outter();</span><br><span class="line">        outter.<span class="keyword">new</span> Inner().print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">            System.out.println(<span class="string">"局部变量："</span> + a);</span><br><span class="line">            System.out.println(<span class="string">"内部类变量："</span> + <span class="keyword">this</span>.a);</span><br><span class="line">            System.out.println(<span class="string">"外部类变量："</span> + Outter.<span class="keyword">this</span>.a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>最后补充一点知识：关于成员内部类的继承问题。一般来说，内部类是很少用来作为继承用的。但是当用来继承的话，要注意两点：</strong></p><p>1）成员内部类的引用方式必须为 Outter.Inner.<br>2）构造器中必须有指向外部类对象的引用，并通过这个引用调用super()。这段代码摘自《Java编程思想》</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithInner</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InheritInner</span> <span class="keyword">extends</span> <span class="title">WithInner</span>.<span class="title">Inner</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// InheritInner() 是不能通过编译的，一定要加上形参</span></span><br><span class="line">    InheritInner(WithInner wi) &#123;</span><br><span class="line">        wi.<span class="keyword">super</span>(); <span class="comment">//必须有这句调用</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WithInner wi = <span class="keyword">new</span> WithInner();</span><br><span class="line">        InheritInner obj = <span class="keyword">new</span> InheritInner(wi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 参考资料：</p><p>　　《java编程思想》</p><p>　　<a href="http://www.cnblogs.com/chenssy/p/3388487.html" target="_blank" rel="noopener">http://www.cnblogs.com/chenssy/p/3388487.html</a></p><p>　　<a href="http://blog.csdn.net/zhangjg_blog/article/details/20000769" target="_blank" rel="noopener">http://blog.csdn.net/zhangjg_blog/article/details/20000769</a></p><p>　　<a href="http://blog.csdn.net/zhangjg_blog/article/details/19996629" target="_blank" rel="noopener">http://blog.csdn.net/zhangjg_blog/article/details/19996629</a></p><p>　　<a href="http://blog.csdn.net/zhaoqianjava/article/details/6849812" target="_blank" rel="noopener">http://blog.csdn.net/zhaoqianjava/article/details/6849812</a></p><p>　　<a href="http://www.cnblogs.com/nerxious/archive/2013/01/24/2875649.html" target="_blank" rel="noopener">http://www.cnblogs.com/nerxious/archive/2013/01/24/2875649.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内部类 </tag>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
